<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customer CSAT Dashboard</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Euclid Circular B Font Integration -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link href="https://fonts.cdnfonts.com/css/euclid-circular-b" rel="stylesheet">

    <style>
        /* CSS Custom Properties - Modern Design System */
        :root {
            /* Modern Primary Palette - Enhanced Green Theme */
            --primary-main: #10b981;
            --primary-gradient: linear-gradient(135deg, #10b981 0%, #059669 100%);
            --primary-surface: rgba(240, 253, 250, 0.8);
            --primary-focus: rgba(209, 250, 229, 0.6);
            --primary-border: rgba(167, 243, 208, 0.3);
            --primary-hover: #059669;
            --primary-pressed: #047857;
            --primary-light: #d1fae5;
            --primary-dark: #064e3b;

            /* Modern Secondary Palette - Enhanced Orange Theme */
            --secondary-main: #f59e0b;
            --secondary-gradient: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            --secondary-surface: rgba(255, 251, 235, 0.8);
            --secondary-focus: rgba(254, 243, 199, 0.6);
            --secondary-border: rgba(252, 211, 77, 0.3);
            --secondary-hover: #d97706;
            --secondary-pressed: #b45309;
            --secondary-light: #fef3c7;
            --secondary-dark: #78350f;

            /* Modern Semantic Colors */
            --success-color: #10b981;
            --success-gradient: linear-gradient(135deg, #10b981 0%, #059669 100%);
            --warning-color: #f59e0b;
            --warning-gradient: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            --error-color: #ef4444;
            --error-gradient: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            --info-color: #3b82f6;
            --info-gradient: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);

            /* Modern Neutral Palette */
            --neutral-50: #fafafa;
            --neutral-100: #f5f5f5;
            --neutral-200: #e5e5e5;
            --neutral-300: #d4d4d4;
            --neutral-400: #a3a3a3;
            --neutral-500: #737373;
            --neutral-600: #525252;
            --neutral-700: #404040;
            --neutral-800: #262626;
            --neutral-900: #171717;

            /* Glassmorphism Effects for White Background */
            --glass-bg: rgba(255, 255, 255, 0.9);
            --glass-border: rgba(0, 0, 0, 0.1);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
            --glass-backdrop: blur(10px);

            /* Typography System */
            --font-family: 'Euclid Circular B', 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-display: 'Euclid Circular B', system-ui, sans-serif;

            /* Modern Spacing System */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --spacing-2xl: 48px;
            --spacing-3xl: 64px;
            --spacing-4xl: 80px;

            /* Modern Border Radius */
            --radius-xs: 4px;
            --radius-sm: 6px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 20px;
            --radius-2xl: 24px;
            --radius-full: 9999px;

            /* Modern Shadow System */
            --shadow-xs: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-sm: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            --shadow-inner: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);

            /* Modern Transitions */
            --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 300ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 500ms cubic-bezier(0.4, 0, 0.2, 1);

            /* Modern Z-Index Scale */
            --z-dropdown: 1000;
            --z-sticky: 1020;
            --z-fixed: 1030;
            --z-modal-backdrop: 1040;
            --z-modal: 1050;
            --z-popover: 1060;
            --z-tooltip: 1070;
        }

        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Ensure all elements inherit the correct font */
        *,
        *::before,
        *::after {
            font-family: inherit;
        }

        body {
            font-family: var(--font-family);
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.6;
            color: var(--neutral-800);
            background: #ffffff;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Modern Typography Hierarchy */
        .heading-xl {
            font-family: var(--font-display);
            font-size: clamp(2rem, 4vw, 3rem);
            font-weight: 700;
            line-height: 1.1;
            color: var(--neutral-900);
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.025em;
        }

        .heading-lg {
            font-family: var(--font-display);
            font-size: clamp(1.5rem, 3vw, 2.25rem);
            font-weight: 600;
            line-height: 1.2;
            color: var(--neutral-900);
            letter-spacing: -0.025em;
        }

        .heading-md {
            font-family: var(--font-display);
            font-size: clamp(1.25rem, 2.5vw, 1.875rem);
            font-weight: 600;
            line-height: 1.3;
            color: var(--neutral-800);
            letter-spacing: -0.025em;
        }

        .heading-sm {
            font-family: var(--font-display);
            font-size: clamp(1.125rem, 2vw, 1.5rem);
            font-weight: 600;
            line-height: 1.4;
            color: var(--neutral-800);
        }

        .body-lg {
            font-family: var(--font-family);
            font-size: 1.125rem;
            font-weight: 400;
            line-height: 1.7;
            color: var(--neutral-700);
        }

        .body-md {
            font-family: var(--font-family);
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.6;
            color: var(--neutral-700);
        }

        .body-sm {
            font-family: var(--font-family);
            font-size: 0.875rem;
            font-weight: 400;
            line-height: 1.5;
            color: var(--neutral-600);
        }

        .caption {
            font-family: var(--font-family);
            font-size: 0.75rem;
            font-weight: 500;
            line-height: 1.4;
            color: var(--neutral-500);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Dashboard Container - CSS Grid Layout */
        .dashboard-container {
            display: grid;
            grid-template-rows: auto 1fr;
            min-height: 100vh;
        }

        /* Hide dashboard initially until authenticated */
        .dashboard-container.hidden {
            display: none;
        }

        /* Modern Header with White Background */
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: var(--glass-backdrop);
            -webkit-backdrop-filter: var(--glass-backdrop);
            border-bottom: 1px solid var(--glass-border);
            box-shadow: var(--shadow-lg);
            position: sticky;
            top: 0;
            z-index: var(--z-sticky);
            transition: all var(--transition-normal);
        }

        .header:hover {
            background: rgba(255, 255, 255, 1);
            box-shadow: var(--shadow-xl);
        }

        .header-content {
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            padding: var(--spacing-lg) var(--spacing-xl);
            max-width: 1400px;
            margin: 0 auto;
            gap: var(--spacing-2xl);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            transition: transform var(--transition-fast);
        }

        .logo:hover {
            transform: scale(1.05);
        }

        .logo-image {
            height: 48px;
            width: auto;
            object-fit: contain;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.1));
        }

        .logo-text {
            font-size: 1.75rem;
            font-weight: 700;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.025em;
        }

        /* Modern Navigation with Pill Design */
        .navigation {
            display: flex;
            gap: var(--spacing-xs);
            background: rgba(0, 0, 0, 0.05);
            padding: var(--spacing-xs);
            border-radius: var(--radius-2xl);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .nav-tab {
            padding: var(--spacing-md) var(--spacing-xl);
            border: none;
            background: transparent;
            color: var(--neutral-700);
            font-family: var(--font-family);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: var(--radius-xl);
            transition: all var(--transition-normal);
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            position: relative;
            white-space: nowrap;
            outline: none;
            border: 2px solid transparent;
            min-height: 44px;
        }

        .nav-tab:hover {
            background: rgba(0, 0, 0, 0.05);
            color: var(--neutral-900);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .nav-tab.active {
            background: var(--primary-gradient);
            color: white;
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            font-weight: 600;
        }

        .nav-tab.active::before {
            content: '';
            position: absolute;
            inset: -2px;
            background: var(--primary-gradient);
            border-radius: var(--radius-xl);
            z-index: -1;
            opacity: 0.3;
            filter: blur(8px);
        }

        /* Modern Quarter Filter Dropdown */
        .quarter-filter {
            position: relative;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .quarter-filter-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--neutral-700);
            white-space: nowrap;
        }

        .quarter-filter-select {
            appearance: none;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-xl);
            padding: var(--spacing-md) var(--spacing-xl);
            padding-right: var(--spacing-2xl);
            font-family: var(--font-family);
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--neutral-800);
            cursor: pointer;
            transition: all var(--transition-normal);
            min-width: 120px;
            box-shadow: var(--shadow-md);
        }

        .quarter-filter-select:hover {
            background: rgba(255, 255, 255, 1);
            border-color: var(--primary-main);
            box-shadow: var(--shadow-lg);
            transform: translateY(-1px);
        }

        .quarter-filter-select:focus {
            outline: none;
            border-color: var(--primary-main);
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
        }

        .quarter-filter-icon {
            position: absolute;
            right: var(--spacing-md);
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            color: var(--neutral-600);
            pointer-events: none;
            transition: transform var(--transition-fast);
        }

        .quarter-filter-select:focus+.quarter-filter-icon {
            transform: translateY(-50%) rotate(180deg);
        }

        /* Enhanced focus indicators for accessibility */
        .nav-tab:focus,
        .nav-tab:focus-visible {
            outline: 2px solid var(--primary-main);
            outline-offset: 2px;
            border-color: var(--primary-main);
            box-shadow: 0 0 0 3px rgba(31, 106, 74, 0.2);
        }

        .nav-tab:focus:not(:focus-visible) {
            outline: none;
            box-shadow: none;
        }

        /* Password Protection Overlay Styles */
        .password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: var(--glass-backdrop);
            -webkit-backdrop-filter: var(--glass-backdrop);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: var(--z-modal);
            transition: opacity var(--transition-normal);
        }

        .password-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .password-container {
            background: var(--glass-bg);
            backdrop-filter: var(--glass-backdrop);
            -webkit-backdrop-filter: var(--glass-backdrop);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-2xl);
            padding: var(--spacing-3xl);
            box-shadow: var(--shadow-2xl);
            max-width: 400px;
            width: 90%;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .password-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--primary-gradient);
            opacity: 0.8;
        }

        .logo-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-2xl);
        }

        .password-logo {
            height: 64px;
            width: auto;
            object-fit: contain;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.1));
        }

        .password-logo-text {
            font-family: var(--font-display);
            font-size: 1.5rem;
            font-weight: 700;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.025em;
        }

        .password-title {
            font-family: var(--font-display);
            font-size: 1.875rem;
            font-weight: 600;
            color: var(--neutral-900);
            margin-bottom: var(--spacing-2xl);
            letter-spacing: -0.025em;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
        }

        .password-label {
            font-family: var(--font-family);
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--neutral-700);
            text-align: left;
        }

        .password-input {
            appearance: none;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-xl);
            padding: var(--spacing-lg) var(--spacing-xl);
            font-family: var(--font-family);
            font-size: 1rem;
            color: var(--neutral-800);
            transition: all var(--transition-normal);
            box-shadow: var(--shadow-md);
        }

        .password-input:hover {
            background: rgba(255, 255, 255, 1);
            border-color: var(--primary-main);
            box-shadow: var(--shadow-lg);
            transform: translateY(-1px);
        }

        .password-input:focus {
            outline: none;
            border-color: var(--primary-main);
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1), var(--shadow-lg);
            background: rgba(255, 255, 255, 1);
        }

        .password-submit {
            background: var(--primary-gradient);
            color: white;
            border: none;
            border-radius: var(--radius-xl);
            padding: var(--spacing-lg) var(--spacing-2xl);
            font-family: var(--font-family);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-normal);
            box-shadow: var(--shadow-lg);
            position: relative;
            overflow: hidden;
        }

        .password-submit:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-xl);
        }

        .password-submit:active {
            transform: translateY(0);
            box-shadow: var(--shadow-md);
        }

        .password-submit:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.3), var(--shadow-xl);
        }

        .error-message {
            background: var(--error-gradient);
            color: white;
            padding: var(--spacing-md) var(--spacing-lg);
            border-radius: var(--radius-lg);
            font-size: 0.875rem;
            font-weight: 500;
            text-align: center;
            box-shadow: var(--shadow-md);
            transition: all var(--transition-normal);
            transform: translateY(-10px);
            opacity: 1;
        }

        .error-message.hidden {
            opacity: 0;
            transform: translateY(-20px);
            pointer-events: none;
        }

        /* Responsive design for password overlay */
        @media (max-width: 480px) {
            .password-container {
                padding: var(--spacing-2xl);
                margin: var(--spacing-lg);
            }

            .password-logo {
                height: 48px;
            }

            .password-title {
                font-size: 1.5rem;
            }

            .password-input,
            .password-submit {
                padding: var(--spacing-md) var(--spacing-lg);
            }
        }



        /* Smooth transitions for tab switching */
        .content-section {
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .content-section.active {
            opacity: 1;
            transform: translateY(0);
        }



        /* Modern Main Content Area */
        .main-content {
            padding: var(--spacing-xl) var(--spacing-xl);
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
            position: relative;
        }



        /* Content Sections */
        .content-section {
            display: none;
        }

        .content-section.active {
            display: block;
        }

        /* F-Pattern Optimized Grid Layout */
        .content-grid {
            display: grid;
            gap: var(--spacing-lg);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr !important;
            gap: var(--spacing-lg) !important;
        }

        .full-width-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--spacing-lg);
        }

        .two-column-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-lg);
        }

        .three-column-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr) !important;
            gap: var(--spacing-lg) !important;
        }

        /* Force grid layout - override any conflicts */
        #csat-metrics.metrics-grid {
            display: grid !important;
            grid-template-columns: 2fr 1fr 1fr !important;
            gap: var(--spacing-lg) !important;
        }

        /* Fix Service Type Breakdown grid */
        #product-breakdown.three-column-grid {
            display: grid !important;
            grid-template-columns: repeat(3, 1fr) !important;
            gap: var(--spacing-lg) !important;
        }

        /* Fix Account Manager cards grid */
        #account-manager-cards.three-column-grid {
            display: grid !important;
            grid-template-columns: repeat(3, 1fr) !important;
            gap: var(--spacing-lg) !important;
        }

        /* Modern Responsive Design */
        @media (max-width: 1024px) {

            .metrics-grid,
            #csat-metrics.metrics-grid {
                grid-template-columns: 1fr 1fr !important;
                gap: var(--spacing-xl) !important;
            }

            .three-column-grid,
            #product-breakdown.three-column-grid,
            #account-manager-cards.three-column-grid {
                grid-template-columns: 1fr 1fr !important;
                gap: var(--spacing-xl) !important;
            }
        }

        @media (max-width: 768px) {
            .header-content {
                grid-template-columns: 1fr;
                gap: var(--spacing-lg);
                text-align: center;
                padding: var(--spacing-lg) var(--spacing-lg);
            }

            .quarter-filter {
                justify-content: center;
                margin-top: var(--spacing-sm);
            }

            .quarter-filter-select {
                min-width: 140px;
            }
        }

        .navigation {
            justify-content: center;
            flex-wrap: wrap;
            gap: var(--spacing-xs);
            padding: var(--spacing-xs);
        }

        .metrics-grid,
        .two-column-grid,
        .three-column-grid {
            grid-template-columns: 1fr !important;
            gap: var(--spacing-lg) !important;
        }

        .main-content {
            padding: var(--spacing-xl) var(--spacing-lg);
        }

        .nav-tab {
            padding: var(--spacing-sm) var(--spacing-lg);
            font-size: 0.8rem;
            min-height: 40px;
        }

        .metric-card {
            padding: var(--spacing-xl);
        }

        .data-table th,
        .data-table td {
            padding: var(--spacing-md) var(--spacing-lg);
        }

        .accordion-header {
            padding: var(--spacing-xl);
        }


        @media (max-width: 480px) {
            .header-content {
                padding: var(--spacing-md);
            }

            .logo-image {
                height: 40px;
            }

            .logo-text {
                font-size: 1.5rem;
            }

            .main-content {
                padding: var(--spacing-lg) var(--spacing-md);
            }

            .metric-card {
                padding: var(--spacing-lg);
            }

            .navigation {
                gap: 2px;
                padding: 4px;
            }

            .nav-tab {
                padding: var(--spacing-sm) var(--spacing-md);
                font-size: 0.75rem;
                min-height: 36px;
            }

            .data-table th,
            .data-table td {
                padding: var(--spacing-sm) var(--spacing-md);
                font-size: 0.8rem;
            }
        }

        /* Core CSS Components from Design System */

        /* Modern Metric Cards for White Background */
        .metric-card {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: var(--glass-backdrop);
            -webkit-backdrop-filter: var(--glass-backdrop);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-2xl);
            padding: var(--spacing-2xl);
            box-shadow: var(--shadow-xl);
            transition: all var(--transition-normal);
            position: relative;
            overflow: hidden;
        }

        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--primary-gradient);
            opacity: 0.8;
        }

        .metric-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: var(--shadow-2xl);
            background: rgba(255, 255, 255, 0.95);
            border-color: rgba(0, 0, 0, 0.15);
        }

        .metric-card:hover::before {
            height: 6px;
            opacity: 1;
        }

        .metric-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: var(--spacing-lg);
        }

        .metric-card-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--neutral-600);
            letter-spacing: 0.1em;
            background: rgba(255, 255, 255, 0.8);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-full);
            backdrop-filter: blur(10px);
        }

        .metric-card-icon {
            width: 32px;
            height: 32px;
            padding: var(--spacing-sm);
            background: var(--primary-gradient);
            border-radius: var(--radius-lg);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .metric-value {
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 700;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-display);
        }

        .metric-value.large {
            font-size: clamp(2.5rem, 6vw, 4rem);
        }

        .metric-value.warning {
            background: var(--warning-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .metric-value.success {
            background: var(--success-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .metric-label {
            font-size: 0.875rem;
            color: var(--neutral-700);
            font-weight: 500;
            line-height: 1.4;
        }

        .metric-change {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            font-size: 0.75rem;
            font-weight: 500;
            margin-top: var(--spacing-sm);
        }

        .metric-change.positive {
            color: var(--success-color);
        }

        .metric-change.negative {
            color: var(--error-color);
        }

        /* Modern Animations and Micro-interactions */
        @keyframes countUp {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.8);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(40px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.8;
            }
        }

        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }

            100% {
                background-position: 200% 0;
            }
        }

        @keyframes shake {
            0%, 100% {
                transform: translateX(0);
            }
            10%, 30%, 50%, 70%, 90% {
                transform: translateX(-5px);
            }
            20%, 40%, 60%, 80% {
                transform: translateX(5px);
            }
        }

        .metric-value.animate {
            animation: countUp 1.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .content-section {
            animation: slideInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .metric-card {
            animation: fadeInScale 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .data-table-container {
            animation: slideInUp 0.7s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .accordion-card {
            animation: slideInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Stagger animation delays */
        .metric-card:nth-child(1) {
            animation-delay: 0.1s;
        }

        .metric-card:nth-child(2) {
            animation-delay: 0.2s;
        }

        .metric-card:nth-child(3) {
            animation-delay: 0.3s;
        }

        .metric-card:nth-child(4) {
            animation-delay: 0.4s;
        }

        .accordion-card:nth-child(1) {
            animation-delay: 0.1s;
        }

        .accordion-card:nth-child(2) {
            animation-delay: 0.2s;
        }

        .accordion-card:nth-child(3) {
            animation-delay: 0.3s;
        }

        .accordion-card:nth-child(4) {
            animation-delay: 0.4s;
        }

        /* Enhanced metric value transitions */
        .metric-value {
            transition: color 0.3s ease;
        }

        /* Loading state for metric values */
        .metric-value.loading {
            opacity: 0.6;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.6;
            }

            50% {
                opacity: 0.3;
            }
        }

        /* Modern Data Table for White Background */
        .data-table-container {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: var(--glass-backdrop);
            -webkit-backdrop-filter: var(--glass-backdrop);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-2xl);
            overflow: hidden;
            box-shadow: var(--shadow-xl);
            transition: all var(--transition-normal);
        }

        .data-table-container:hover {
            box-shadow: var(--shadow-2xl);
            transform: translateY(-2px);
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-family: var(--font-family);
            font-size: 0.875rem;
        }

        .data-table thead {
            background: var(--primary-gradient);
            color: white;
            position: relative;
        }

        .data-table thead::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: rgba(255, 255, 255, 0.2);
        }

        .data-table th {
            padding: var(--spacing-lg) var(--spacing-xl);
            text-align: left;
            font-weight: 600;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            border: none;
            position: relative;
        }

        .data-table td {
            padding: var(--spacing-lg) var(--spacing-xl);
            border: none;
            vertical-align: middle;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .data-table tbody tr {
            transition: all var(--transition-fast);
            position: relative;
        }

        .data-table tbody tr:nth-child(even) {
            background: rgba(0, 0, 0, 0.02);
        }

        .data-table tbody tr:hover {
            background: rgba(0, 0, 0, 0.05);
            cursor: pointer;
            transform: scale(1.01);
        }

        .data-table tbody tr:hover td {
            border-bottom-color: rgba(0, 0, 0, 0.1);
        }

        .data-table tbody tr:last-child td {
            border-bottom: none;
        }

        .table-cell-link {
            color: var(--primary-main);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.2s ease;
            /* Accessibility enhancements */
            outline: none;
            border-radius: var(--radius-sm);
            padding: 2px 4px;
            margin: -2px -4px;
        }

        .table-cell-link:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Enhanced focus indicators for table links */
        .table-cell-link:focus,
        .table-cell-link:focus-visible {
            outline: 2px solid var(--primary-main);
            outline-offset: 2px;
            background: var(--primary-focus);
            text-decoration: underline;
        }

        .table-cell-link:focus:not(:focus-visible) {
            outline: none;
            background: transparent;
        }

        .table-status-badge {
            display: inline-block;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .table-status-badge.completed {
            background: var(--success-color);
            color: white;
        }

        .table-status-badge.pending {
            background: var(--warning-color);
            color: white;
        }

        /* Modern Accordion for White Background */
        .accordion-container {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-lg);
        }

        .accordion-card {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: var(--glass-backdrop);
            -webkit-backdrop-filter: var(--glass-backdrop);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-2xl);
            box-shadow: var(--shadow-lg);
            overflow: hidden;
            transition: all var(--transition-normal);
            position: relative;
        }

        .accordion-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary-gradient);
            opacity: 0;
            transition: opacity var(--transition-normal);
        }

        .accordion-card:hover {
            box-shadow: var(--shadow-2xl);
            transform: translateY(-4px);
            background: rgba(255, 255, 255, 0.95);
        }

        .accordion-card:hover::before {
            opacity: 1;
        }

        .accordion-card.expanded {
            background: rgba(255, 255, 255, 0.95);
            box-shadow: var(--shadow-2xl);
        }

        .accordion-card.expanded::before {
            opacity: 1;
            height: 4px;
        }

        .accordion-header {
            padding: var(--spacing-2xl);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: transparent;
            border: none;
            width: 100%;
            text-align: left;
            transition: all var(--transition-normal);
            position: relative;
            outline: none;
            border: 2px solid transparent;
        }

        .accordion-header:hover {
            background: rgba(0, 0, 0, 0.03);
        }

        .accordion-header:focus {
            background: rgba(0, 0, 0, 0.05);
            outline: 2px solid var(--primary-main);
            outline-offset: -2px;
        }

        /* Enhanced focus indicators for accordion headers */
        .accordion-header:focus,
        .accordion-header:focus-visible {
            outline: 2px solid var(--primary-main);
            outline-offset: -2px;
            border-color: var(--primary-main);
            box-shadow: 0 0 0 3px rgba(31, 106, 74, 0.2);
            background: var(--primary-focus);
        }

        .accordion-header:focus:not(:focus-visible) {
            outline: none;
            box-shadow: none;
        }



        .accordion-header-content {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
            flex: 1;
        }

        .accordion-title {
            font-family: var(--font-family);
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--primary-main);
            margin: 0;
        }

        .accordion-subtitle {
            font-family: var(--font-family);
            font-size: 0.875rem;
            color: #666;
            margin: 0;
        }

        .accordion-meta {
            display: flex;
            gap: var(--spacing-lg);
            align-items: center;
        }

        .accordion-rating {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            font-weight: 600;
            padding: var(--spacing-sm) var(--spacing-lg);
            border-radius: var(--radius-full);
            font-size: 0.875rem;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--shadow-md);
        }

        .accordion-rating::before {
            content: '';
            position: absolute;
            inset: 0;
            opacity: 0.9;
            z-index: -1;
        }

        .accordion-rating.excellent::before {
            background: var(--success-gradient);
        }

        .accordion-rating.excellent {
            color: white;
        }

        .accordion-rating.good::before {
            background: var(--primary-gradient);
        }

        .accordion-rating.good {
            color: white;
        }

        .accordion-rating.average::before {
            background: var(--warning-gradient);
        }

        .accordion-rating.average {
            color: white;
        }

        .accordion-rating.poor::before {
            background: var(--error-gradient);
        }

        .accordion-rating.poor {
            color: white;
        }

        .accordion-icon {
            width: 20px;
            height: 20px;
            transition: transform 0.3s ease;
            color: var(--primary-main);
        }

        .accordion-card.expanded .accordion-icon {
            transform: rotate(180deg);
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            background: var(--primary-surface);
        }

        .accordion-card.expanded .accordion-content {
            /* Allow full content to be visible */
            max-height: none !important;
            overflow: visible !important;
            padding: var(--spacing-lg);
            height: auto;
        }

        .accordion-body {
            display: grid;
            gap: var(--spacing-md);
        }

        .survey-question {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: var(--spacing-md);
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--primary-border);
        }

        .survey-question:last-child {
            border-bottom: none;
        }

        .survey-question-label {
            font-weight: 500;
            color: var(--primary-main);
            font-size: 0.875rem;
        }

        .survey-question-answer {
            color: #333;
            font-size: 0.875rem;
        }

        /* Modern Progress Bar Component */
        .progress-container {
            margin: var(--spacing-lg) 0;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            font-size: 0.875rem;
        }

        .progress-label-text {
            font-weight: 500;
            color: var(--neutral-700);
        }

        .progress-label-value {
            font-weight: 700;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 1rem;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: var(--radius-full);
            overflow: hidden;
            position: relative;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .progress-bar.large {
            height: 16px;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary-gradient);
            border-radius: var(--radius-full);
            transition: width 1.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }

        .progress-fill.success {
            background: var(--success-color);
        }

        .progress-fill.warning {
            background: var(--warning-color);
        }

        .progress-fill.error {
            background: var(--error-color);
        }

        /* Modern progress bar shine animation */
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.6),
                    transparent);
            animation: progressShine 3s ease-in-out infinite;
        }

        @keyframes progressShine {
            0% {
                transform: translateX(-100%);
            }

            50% {
                transform: translateX(100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        .progress-fill.success {
            background: var(--success-gradient);
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.4);
        }

        .progress-fill.warning {
            background: var(--warning-gradient);
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.4);
        }

        .progress-fill.error {
            background: var(--error-gradient);
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.4);
        }

        /* Modern Skeleton Loading Animation */
        .skeleton {
            background: linear-gradient(90deg,
                    rgba(255, 255, 255, 0.1) 25%,
                    rgba(255, 255, 255, 0.3) 50%,
                    rgba(255, 255, 255, 0.1) 75%);
            background-size: 200% 100%;
            animation: shimmer 2s infinite ease-in-out;
            border-radius: var(--radius-lg);
            position: relative;
            overflow: hidden;
        }

        .skeleton::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.4),
                    transparent);
            animation: shimmer 2s infinite ease-in-out;
        }

        .skeleton-text {
            height: 1rem;
            margin-bottom: var(--spacing-xs);
        }

        .skeleton-text.large {
            height: 1.5rem;
        }

        .skeleton-text.small {
            height: 0.75rem;
        }

        .skeleton-text.title {
            height: 2rem;
            width: 60%;
        }

        .skeleton-card {
            padding: var(--spacing-lg);
            border-radius: var(--radius-lg);
            border: 1px solid var(--primary-border);
        }

        .skeleton-metric {
            height: 3rem;
            width: 80%;
            margin-bottom: var(--spacing-sm);
        }

        .skeleton-table-row {
            height: 3rem;
            margin-bottom: var(--spacing-xs);
        }

        .skeleton-progress {
            height: 8px;
            width: 100%;
            margin: var(--spacing-sm) 0;
        }

        .skeleton-table-row {
            height: 3rem;
            width: 100%;
            margin-bottom: var(--spacing-xs);
        }

        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }

            100% {
                background-position: 200% 0;
            }
        }

        /* Loading state overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--primary-border);
            border-top: 3px solid var(--primary-main);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }



        /* Component Responsive Adjustments */
        @media (max-width: 768px) {
            .metric-card {
                padding: var(--spacing-md);
            }

            .metric-value {
                font-size: 2rem;
            }

            .metric-value.large {
                font-size: 2.5rem;
            }

            .data-table th,
            .data-table td {
                padding: var(--spacing-sm) var(--spacing-md);
            }

            .accordion-header {
                padding: var(--spacing-md);
            }

            .accordion-card.expanded .accordion-content {
                padding: var(--spacing-md);
                /* max-height will be set dynamically by JavaScript */
            }

            .survey-question {
                grid-template-columns: 1fr;
                gap: var(--spacing-xs);
            }


        }

        /* Error Handling and User Feedback Styles */
        .error-container {
            position: fixed;
            top: 20px;
            right: 20px;
            max-width: 400px;
            z-index: 1000;
            pointer-events: none;
        }

        .error-message {
            padding: var(--spacing-md);
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-sm);
            box-shadow: var(--shadow-lg);
            pointer-events: auto;
            font-family: var(--font-family);
            font-size: 0.875rem;
            line-height: 1.4;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            animation: slideInRight 0.3s ease-out;
        }

        .error-message.error {
            background: var(--error-color);
            color: white;
        }

        .error-message.warning {
            background: var(--warning-color);
            color: white;
        }

        .error-message.info {
            background: var(--primary-main);
            color: white;
        }

        .error-message.success {
            background: var(--success-color);
            color: white;
        }

        .error-message-content {
            flex: 1;
            margin-right: var(--spacing-sm);
        }

        .error-message-close {
            background: none;
            border: none;
            color: inherit;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            opacity: 0.8;
            transition: opacity 0.2s ease;
        }

        .error-message-close:hover {
            opacity: 1;
        }

        /* Empty State Styles */
        .empty-state {
            text-align: center;
            padding: var(--spacing-2xl);
            color: #666;
        }

        .empty-state-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto var(--spacing-lg);
            opacity: 0.5;
        }

        .empty-state-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--primary-main);
            margin-bottom: var(--spacing-sm);
        }

        .empty-state-description {
            font-size: 0.875rem;
            line-height: 1.5;
            margin-bottom: var(--spacing-lg);
        }

        .empty-state-action {
            background: var(--primary-gradient);
            color: white;
            border: none;
            padding: var(--spacing-md) var(--spacing-2xl);
            border-radius: var(--radius-full);
            font-family: var(--font-family);
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-normal);
            outline: none;
            border: 2px solid transparent;
            box-shadow: var(--shadow-lg);
            position: relative;
            overflow: hidden;
        }

        .empty-state-action::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--primary-gradient);
            opacity: 0;
            transition: opacity var(--transition-normal);
        }

        .empty-state-action:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-xl);
        }

        .empty-state-action:hover::before {
            opacity: 0.1;
        }

        .empty-state-action:active {
            transform: translateY(0);
            box-shadow: var(--shadow-md);
        }

        /* Enhanced focus indicators for buttons */
        .empty-state-action:focus,
        .empty-state-action:focus-visible {
            outline: 2px solid var(--primary-main);
            outline-offset: 2px;
            border-color: white;
            box-shadow: 0 0 0 4px rgba(31, 106, 74, 0.2);
        }

        .empty-state-action:focus:not(:focus-visible) {
            outline: none;
            box-shadow: none;
        }

        /* Loading States */
        .loading-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-2xl);
            min-height: 200px;
        }

        .loading-spinner-large {
            width: 48px;
            height: 48px;
            border: 4px solid var(--primary-border);
            border-top: 4px solid var(--primary-main);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: var(--spacing-lg);
        }

        .loading-text {
            color: #666;
            font-size: 0.875rem;
            text-align: center;
        }

        /* Progress Indicators */
        .progress-indicator {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary-surface);
            z-index: 1001;
            overflow: hidden;
        }

        .progress-indicator-bar {
            height: 100%;
            background: var(--primary-main);
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-indicator-bar.indeterminate {
            width: 30%;
            animation: progressIndeterminate 2s linear infinite;
        }

        @keyframes progressIndeterminate {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(400%);
            }
        }

        /* Retry Button */
        .retry-button {
            background: var(--secondary-main);
            color: white;
            border: none;
            padding: var(--spacing-sm) var(--spacing-lg);
            border-radius: var(--radius-md);
            font-family: var(--font-family);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
            /* Accessibility enhancements */
            outline: none;
            border: 2px solid transparent;
        }

        .retry-button:hover {
            background: var(--secondary-hover);
        }

        .retry-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        /* Enhanced focus indicators for retry button */
        .retry-button:focus,
        .retry-button:focus-visible {
            outline: 2px solid var(--secondary-main);
            outline-offset: 2px;
            border-color: white;
            box-shadow: 0 0 0 4px rgba(255, 157, 24, 0.2);
        }

        .retry-button:focus:not(:focus-visible) {
            outline: none;
            box-shadow: none;
        }

        /* Connection Status Indicator */
        .connection-status {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-md);
            font-size: 0.75rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .connection-status.online {
            background: var(--success-color);
            color: white;
        }

        .connection-status.offline {
            background: var(--error-color);
            color: white;
        }

        .connection-status.reconnecting {
            background: var(--warning-color);
            color: white;
        }

        .connection-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }

        /* Partial Data Warning */
        .partial-data-warning {
            background: var(--secondary-surface);
            border: 1px solid var(--secondary-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
            display: flex;
            align-items: flex-start;
            gap: var(--spacing-sm);
        }

        .partial-data-warning-icon {
            color: var(--secondary-main);
            font-size: 1.2rem;
            margin-top: 2px;
        }

        .partial-data-warning-content {
            flex: 1;
        }

        .partial-data-warning-title {
            font-weight: 600;
            color: var(--secondary-pressed);
            margin-bottom: var(--spacing-xs);
            font-size: 0.875rem;
        }

        .partial-data-warning-text {
            font-size: 0.8rem;
            color: #666;
            line-height: 1.4;
        }

        /* Animation Keyframes */
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }

            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }

            to {
                opacity: 0;
                transform: translateY(-10px);
            }
        }

        /* Responsive adjustments for error handling */
        @media (max-width: 768px) {
            .error-container {
                left: 20px;
                right: 20px;
                max-width: none;
            }

            .connection-status {
                left: 50%;
                transform: translateX(-50%);
            }

            .empty-state {
                padding: var(--spacing-lg);
            }

            .loading-state {
                padding: var(--spacing-lg);
                min-height: 150px;
            }
        }

        /* Accessibility Enhancements */

        /* Screen reader only content */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Skip to main content link for keyboard navigation */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 6px;
            background: var(--primary-main);
            color: white;
            padding: 8px;
            text-decoration: none;
            border-radius: 4px;
            z-index: 1000;
            font-weight: 600;
        }

        .skip-link:focus {
            top: 6px;
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            :root {
                --primary-main: #000000;
                --primary-surface: #ffffff;
                --primary-border: #000000;
                --secondary-main: #ff6600;
            }

            /* removed debug borders */
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {

            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }

            .metric-value.animate {
                animation: none;
            }

            .progress-fill {
                transition: none;
            }
        }

        /* Focus management for modal-like states */
        .focus-trap {
            position: relative;
        }

        .focus-trap::before,
        .focus-trap::after {
            content: '';
            position: absolute;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }

        /* Enhanced keyboard navigation indicators */
        .keyboard-navigation-active *:focus {
            outline: 2px solid var(--primary-main) !important;
            outline-offset: 2px !important;
        }

        /* Performance optimizations for large datasets */
        .virtual-scroll-container {
            height: 400px;
            overflow-y: auto;
            position: relative;
        }

        .virtual-scroll-content {
            position: relative;
        }

        .virtual-scroll-item {
            position: absolute;
            width: 100%;
            left: 0;
        }

        /* Optimize rendering for large tables */
        .data-table {
            contain: layout style paint;
            will-change: scroll-position;
        }

        .data-table tbody {
            contain: layout style;
        }

        /* GPU acceleration for animations */
        .metric-value.animate,
        .progress-fill,
        .accordion-content {
            will-change: transform, opacity;
            transform: translateZ(0);
        }

        /* Cross-browser compatibility */
        .nav-tab,
        .accordion-header,
        .table-cell-link,
        .empty-state-action,
        .retry-button {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        /* Vendor prefixes for animations */
        @-webkit-keyframes countUp {
            from {
                opacity: 0;
                -webkit-transform: translateY(20px);
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                -webkit-transform: translateY(0);
                transform: translateY(0);
            }
        }

        @-webkit-keyframes shimmer {
            0% {
                background-position: -200% 0;
            }

            100% {
                background-position: 200% 0;
            }
        }

        @-webkit-keyframes spin {
            0% {
                -webkit-transform: rotate(0deg);
                transform: rotate(0deg);
            }

            100% {
                -webkit-transform: rotate(360deg);
                transform: rotate(360deg);
            }
        }

        /* Utility Classes */
        .text-center {
            text-align: center;
        }

        .mb-lg {
            margin-bottom: var(--spacing-md);
        }

        .mt-lg {
            margin-top: var(--spacing-lg);
        }

        .hidden {
            display: none !important;
        }

        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }

        .fade-out {
            animation: fadeOut 0.3s ease-out;
        }

        /* Responsive font scaling for better readability */
        @media (max-width: 480px) {
            html {
                font-size: 14px;
            }
        }

        @media (min-width: 1200px) {
            html {
                font-size: 16px;
            }
        }

        /* Print styles for accessibility */
        @media print {

            .navigation,
            .error-container,
            .connection-status,
            .progress-indicator {
                display: none !important;
            }

            .content-section {
                display: block !important;
            }

            .accordion-content {
                /* max-height will be set dynamically by JavaScript */
                padding: var(--spacing-md) !important;
            }
        }
    </style>
</head>

<body>
    <!-- Google Sheets API Integration Script -->
    <script>
        // Google Sheets API Configuration
        // To use this integration:
        // 1. Create a Google Cloud Project and enable the Sheets API
        // 2. Create a service account and download the JSON key file
        // 3. Generate an API key for the service account
        // 4. Share your Google Sheet with the service account email
        // 5. Replace the placeholders below with your actual values
        // Secure configuration - no sensitive data exposed
        const API_CONFIG = {
            baseUrl: '/api',
            endpoints: {
                auth: '/api/auth',
                sheetsData: '/api/sheets-data'
            }
        };

        // Data cache configuration
        const CACHE_CONFIG = {
            duration: 30000, // 30 seconds in milliseconds
            retryInterval: 30000, // 30 seconds retry interval
            maxRetries: 3
        };

        // Global data cache
        let dataCache = {
            data: null,
            timestamp: null,
            isLoading: false,
            retryCount: 0
        };

        // Error handling utilities
        class APIError extends Error {
            constructor(message, type, statusCode = null) {
                super(message);
                this.name = 'APIError';
                this.type = type;
                this.statusCode = statusCode;
            }
        }

        // Google Sheets API Integration Class
        class GoogleSheetsAPI {
            constructor(config) {
                this.config = config;
                this.authToken = localStorage.getItem('auth_token');
            }

            /**
             * Fetch data from secure backend API
             * Uses session-based authentication
             */
            async fetchSheetData() {
                try {
                    if (!this.authToken) {
                        throw new APIError('Not authenticated', 'AUTH_ERROR', 401);
                    }

                    const response = await fetch(this.config.endpoints.sheetsData, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.authToken}`
                        }
                    });

                    if (!response.ok) {
                        throw new APIError(
                            `HTTP ${response.status}: ${response.statusText}`,
                            'HTTP_ERROR',
                            response.status
                        );
                    }

                    const data = await response.json();

                    if (!data.values || !Array.isArray(data.values)) {
                        throw new APIError(
                            'Invalid data format received from Google Sheets',
                            'DATA_FORMAT_ERROR'
                        );
                    }

                    return this.parseSheetData(data.values);
                } catch (error) {
                    if (error instanceof APIError) {
                        throw error;
                    }

                    // Handle network errors
                    if (error.name === 'TypeError' && error.message.includes('fetch')) {
                        throw new APIError(
                            'Network connection failed. Please check your internet connection.',
                            'NETWORK_ERROR'
                        );
                    }

                    throw new APIError(
                        `Unexpected error: ${error.message}`,
                        'UNKNOWN_ERROR'
                    );
                }
            }

            /**
             * Parse raw sheet data into structured survey responses
             */
            parseSheetData(rawData) {
                if (rawData.length < 2) {
                    throw new APIError(
                        'Sheet must contain at least a header row and one data row',
                        'INSUFFICIENT_DATA'
                    );
                }

                const headers = rawData[0];
                const dataRows = rawData.slice(1);

                // Updated column mapping based on current dataset structure
                const columnMapping = {
                    // Language selection
                    language: 0, // "  | Choose your Language"

                    // Company name (Arabic: col 2, English: col 16)
                    companyNameArabic: 1, // "   "
                    companyNameEnglish: 15, // "Please provide your company name"

                    // Service type (Arabic: col 3, English: col 17)
                    serviceTypeArabic: 2, // " "
                    serviceTypeEnglish: 16, // "Service Type"

                    // Overall satisfaction (Arabic: col 4, English: col 18)
                    overallSatisfactionArabic: 3, // "       "
                    overallSatisfactionEnglish: 17, // "How satisfied are you with the overall experience with Starlinks?"

                    // NPS Score (Arabic: col 5, English: col 19)
                    npsScoreArabic: 4, // "       "
                    npsScoreEnglish: 18, // "How likely are you to recommend Starlinks to other businesses?"

                    // Last-mile satisfaction (Arabic: col 6, English: col 20)
                    lastMileSatisfactionArabic: 5, // "     "
                    lastMileSatisfactionEnglish: 19, // "How satisfied are you with the *last-mile *delivery services?"

                    // Reverse delivery satisfaction (Arabic: col 7, English: col 21)
                    reverseDeliverySatisfactionArabic: 6, // "      ( )"
                    reverseDeliverySatisfactionEnglish: 20, // "How satisfied are you with the *reverse* delivery services? (If Applicable)"

                    // Fulfillment satisfaction (Arabic: col 8, English: col 22)
                    fulfillmentSatisfactionArabic: 7, // "        ( )"
                    fulfillmentSatisfactionEnglish: 21, // "How satisfied are you with the *fulfillment* services?* (If Applicable)"

                    // Communication clarity (Arabic: col 9, English: col 23)
                    communicationClarityArabic: 8, // "  "
                    communicationClarityEnglish: 22, // "Clarity of communication you receive"

                    // Responsiveness (Arabic: col 10, English: col 24)
                    responsivenessArabic: 9, // "    "
                    responsivenessEnglish: 23, // "Responsiveness and professionalism of your account manager"

                    // Problem resolution (Arabic: col 11, English: col 25)
                    problemResolutionArabic: 10, // "       "
                    problemResolutionEnglish: 24, // "Effectiveness at resolving the issues or concerns you bring up"

                    // Customization ability (Arabic: col 12, English: col 26)
                    customizationAbilityArabic: 11, // "        "
                    customizationAbilityEnglish: 25, // "Ability to tailor their approach to meet your specific needs and preferences"

                    // Systems satisfaction (Arabic: col 13, English: col 27)
                    systemsSatisfactionArabic: 12, // "          "
                    systemsSatisfactionEnglish: 26, // "How satisfied are you with Starlinks' systems and tools used in daily operations?"

                    // IT support satisfaction (Arabic: col 14, English: col 28)
                    itSupportSatisfactionArabic: 13, // "                "
                    itSupportSatisfactionEnglish: 27, // "How satisfied are you with the IT operations support team in handling issues and processing change requests?"

                    // Suggestions (Arabic: col 15, English: col 29)
                    suggestionsArabic: 14, // "     "
                    suggestionsEnglish: 28, // "Do you have any suggestions for improving our services?"

                    // Account manager (Arabic: col 30, English: col 31)
                    accountManagerArabic: 29, // "   "
                    accountManagerEnglish: 30, // "Name of designated account manager:"

                    // Submitted at (col 32)
                    submittedAt: 31, // "Submitted At"

                    // Token - for unique identification (using submittedAt column as token)
                    token: 31 // "Submitted At" (using same as submittedAt for unique identification)
                };

                const parsedData = dataRows
                    .filter(row => row.length > 0) // Filter out completely empty rows
                    .map((row, index) => {
                        try {
                            // Helper function to get non-empty value from bilingual columns
                            const getBilingualValue = (arabicIndex, englishIndex) => {
                                const arabicValue = this.sanitizeString(row[arabicIndex]);
                                const englishValue = this.sanitizeString(row[englishIndex]);

                                // Return non-empty value, prioritizing Arabic if both exist
                                if (arabicValue && arabicValue.trim()) return arabicValue;
                                if (englishValue && englishValue.trim()) return englishValue;
                                return null;
                            };

                            // Helper function to get non-empty numeric value from bilingual columns
                            const getBilingualNumber = (arabicIndex, englishIndex, min = 1, max = 5) => {
                                const arabicValue = this.parseNumber(row[arabicIndex], min, max);
                                const englishValue = this.parseNumber(row[englishIndex], min, max);

                                // Return non-null value, prioritizing Arabic if both exist
                                if (arabicValue !== null) return arabicValue;
                                if (englishValue !== null) return englishValue;
                                return null;
                            };

                            // Extract data using bilingual logic
                            const companyName = getBilingualValue(columnMapping.companyNameArabic, columnMapping.companyNameEnglish);
                            const rawServiceType = getBilingualValue(columnMapping.serviceTypeArabic, columnMapping.serviceTypeEnglish);
                            const rawAccountManager = getBilingualValue(columnMapping.accountManagerArabic, columnMapping.accountManagerEnglish);
                            const suggestions = getBilingualValue(columnMapping.suggestionsArabic, columnMapping.suggestionsEnglish);

                            // Normalize service type and account manager
                            const processor = new SurveyDataProcessor();
                            const serviceType = processor.normalizeServiceType(rawServiceType);
                            const accountManager = processor.normalizeAccountManager(rawAccountManager);

                            // Skip rows without company name (essential field)
                            if (!companyName) {
                                return null;
                            }

                            return {
                                id: index + 1,
                                companyName: companyName,
                                serviceType: serviceType,
                                overallSatisfaction: getBilingualNumber(columnMapping.overallSatisfactionArabic, columnMapping.overallSatisfactionEnglish, 1, 5),
                                npsScore: getBilingualNumber(columnMapping.npsScoreArabic, columnMapping.npsScoreEnglish, 1, 10),
                                lastMileSatisfaction: getBilingualNumber(columnMapping.lastMileSatisfactionArabic, columnMapping.lastMileSatisfactionEnglish, 1, 5),
                                reverseDeliverySatisfaction: getBilingualNumber(columnMapping.reverseDeliverySatisfactionArabic, columnMapping.reverseDeliverySatisfactionEnglish, 1, 5),
                                fulfillmentSatisfaction: getBilingualNumber(columnMapping.fulfillmentSatisfactionArabic, columnMapping.fulfillmentSatisfactionEnglish, 1, 5),
                                accountManager: accountManager,
                                communicationClarity: getBilingualNumber(columnMapping.communicationClarityArabic, columnMapping.communicationClarityEnglish, 1, 5),
                                responsiveness: getBilingualNumber(columnMapping.responsivenessArabic, columnMapping.responsivenessEnglish, 1, 5),
                                problemResolution: getBilingualNumber(columnMapping.problemResolutionArabic, columnMapping.problemResolutionEnglish, 1, 5),
                                customizationAbility: getBilingualNumber(columnMapping.customizationAbilityArabic, columnMapping.customizationAbilityEnglish, 1, 5),
                                systemsSatisfaction: getBilingualNumber(columnMapping.systemsSatisfactionArabic, columnMapping.systemsSatisfactionEnglish, 1, 5),
                                itSupportSatisfaction: getBilingualNumber(columnMapping.itSupportSatisfactionArabic, columnMapping.itSupportSatisfactionEnglish, 1, 5),
                                suggestions: suggestions,
                                submittedAt: this.parseDate(row[columnMapping.submittedAt]),
                                isCompleted: Boolean(row[columnMapping.submittedAt] && row[columnMapping.submittedAt].toString().trim()),
                                // Store additional metadata
                                language: this.sanitizeString(row[columnMapping.language]),
                                token: this.sanitizeString(row[columnMapping.token]),
                                // Store raw values for debugging
                                rawServiceType: rawServiceType,
                                rawAccountManager: rawAccountManager
                            };
                        } catch (parseError) {
                            console.warn(`Error parsing row ${index + 2}:`, parseError.message);
                            console.warn('Row data:', row);
                            return null;
                        }
                    })
                    .filter(item => item !== null); // Remove failed parsing attempts

                // Validate the parsed data
                this.validateBilingualData(parsedData);

                console.log(` Successfully parsed ${parsedData.length} survey responses`);
                return parsedData;
            }

            /**
             * Validate bilingual data structure and provide debugging info
             */
            validateBilingualData(data) {
                console.log(' Bilingual Data Validation Report:');

                const stats = {
                    totalRows: data.length,
                    arabicResponses: 0,
                    englishResponses: 0,
                    mixedResponses: 0,
                    emptyResponses: 0,
                    completedSurveys: 0,
                    languageDistribution: {}
                };

                data.forEach((row, index) => {
                    if (row.language) {
                        stats.languageDistribution[row.language] = (stats.languageDistribution[row.language] || 0) + 1;
                    }

                    if (row.isCompleted) {
                        stats.completedSurveys++;
                    }
                });

                console.log(' Statistics:', stats);

                // Check for common issues
                const issues = [];
                if (stats.totalRows === 0) {
                    issues.push('No data found - check API connection and spreadsheet ID');
                }
                if (stats.completedSurveys === 0) {
                    issues.push('No completed surveys found - check submission timestamp column');
                }

                if (issues.length > 0) {
                    console.warn(' Issues found:', issues);
                }

                return { stats, issues };
            }

            /**
             * Utility methods for data sanitization and validation
             */
            sanitizeString(value) {
                if (value === null || value === undefined) return '';
                return String(value).trim();
            }

            parseNumber(value, min = null, max = null) {
                if (value === null || value === undefined || value === '') return null;

                const num = Number(value);
                if (isNaN(num)) return null;

                if (min !== null && num < min) return null;
                if (max !== null && num > max) return null;

                return num;
            }

            parseDate(value) {
                if (!value) return null;

                try {
                    const date = new Date(value);
                    return isNaN(date.getTime()) ? null : date;
                } catch (error) {
                    return null;
                }
            }
        }

        // Data Cache Manager
        class DataCacheManager {
            constructor(cacheConfig) {
                this.config = cacheConfig;
            }

            /**
             * Check if cached data is still valid
             */
            isCacheValid() {
                if (!dataCache.data || !dataCache.timestamp) {
                    return false;
                }

                const now = Date.now();
                const cacheAge = now - dataCache.timestamp;

                return cacheAge < this.config.duration;
            }

            /**
             * Get cached data if valid, otherwise fetch new data
             */
            async getData(forceRefresh = false) {
                // Return cached data if valid and not forcing refresh
                if (!forceRefresh && this.isCacheValid()) {
                    return dataCache.data;
                }

                // Prevent multiple simultaneous requests
                if (dataCache.isLoading) {
                    return this.waitForCurrentRequest();
                }

                return this.fetchFreshData();
            }

            /**
             * Wait for current request to complete
             */
            async waitForCurrentRequest() {
                return new Promise((resolve) => {
                    const checkInterval = setInterval(() => {
                        if (!dataCache.isLoading) {
                            clearInterval(checkInterval);
                            resolve(dataCache.data);
                        }
                    }, 100);
                });
            }

            /**
             * Fetch fresh data from API
             */
            async fetchFreshData() {
                dataCache.isLoading = true;

                try {
                    const api = new GoogleSheetsAPI(API_CONFIG);
                    const freshData = await api.fetchSheetData();

                    // Update cache
                    dataCache.data = freshData;
                    dataCache.timestamp = Date.now();
                    dataCache.retryCount = 0; // Reset retry count on success

                    return freshData;
                } catch (error) {
                    await this.handleFetchError(error);
                    throw error;
                } finally {
                    dataCache.isLoading = false;
                }
            }

            /**
             * Handle fetch errors with retry logic and user feedback
             */
            async handleFetchError(error) {
                dataCache.retryCount++;

                // Log error for debugging
                console.error('Data fetch error:', {
                    type: error.type,
                    message: error.message,
                    statusCode: error.statusCode,
                    retryCount: dataCache.retryCount,
                    timestamp: new Date().toISOString()
                });

                // Update connection status
                if (error.type === 'NETWORK_ERROR') {
                    errorManager.updateConnectionStatus('offline');
                } else {
                    errorManager.updateConnectionStatus('reconnecting');
                }

                // Show user-friendly error message with recovery options
                const userMessage = this.getUserFriendlyErrorMessage(error);
                const showRetry = dataCache.retryCount < this.config.maxRetries;

                errorManager.showError(userMessage, 'error', showRetry ? 0 : 8000, {
                    showRetry: showRetry,
                    onRetry: () => {
                        this.getData(true).catch(retryError => {
                            console.error('Manual retry failed:', retryError.message);
                        });
                    }
                });

                // Schedule automatic retry if under max retry limit
                if (dataCache.retryCount < this.config.maxRetries) {
                    const retryDelay = this.calculateRetryDelay(dataCache.retryCount);

                    setTimeout(() => {
                        errorManager.updateConnectionStatus('reconnecting');
                        this.getData(true).then(() => {
                            errorManager.updateConnectionStatus('online');
                            errorManager.showError('Connection restored successfully', 'success', 3000);
                        }).catch(retryError => {
                            console.error('Automatic retry failed:', retryError.message);
                        });
                    }, retryDelay);
                }
            }

            /**
             * Calculate exponential backoff delay for retries
             */
            calculateRetryDelay(retryCount) {
                const baseDelay = this.config.retryInterval;
                const maxDelay = 300000; // 5 minutes max
                const delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay);
                return delay;
            }

            /**
             * Get user-friendly error message with context
             */
            getUserFriendlyErrorMessage(error) {
                const baseMessage = window.DashboardAPI.getErrorMessage(error);
                const suggestions = errorManager.getRecoverySuggestions(error);

                if (dataCache.retryCount < this.config.maxRetries) {
                    return `${baseMessage} Retrying automatically in a few moments...`;
                } else {
                    return `${baseMessage} Please try the following: ${suggestions.slice(0, 2).join(', ')}.`;
                }
            }

            /**
             * Clear cache (useful for manual refresh)
             */
            clearCache() {
                dataCache.data = null;
                dataCache.timestamp = null;
                dataCache.retryCount = 0;
            }
        }

        // Enhanced Error Display Manager
        class ErrorDisplayManager {
            constructor() {
                this.errorContainer = null;
                this.connectionStatus = null;
                this.progressIndicator = null;
                this.createErrorContainer();
                this.createConnectionStatus();
                this.createProgressIndicator();
                this.setupGlobalErrorHandling();
            }

            createErrorContainer() {
                // Create error message container if it doesn't exist
                if (!document.getElementById('error-container')) {
                    const container = document.createElement('div');
                    container.id = 'error-container';
                    container.className = 'error-container';
                    document.body.appendChild(container);
                }
                this.errorContainer = document.getElementById('error-container');
            }

            createConnectionStatus() {
                // Create connection status indicator
                if (!document.getElementById('connection-status')) {
                    const status = document.createElement('div');
                    status.id = 'connection-status';
                    status.className = 'connection-status online';
                    status.innerHTML = `
                        <div class="connection-status-dot"></div>
                        <span>Connected</span>
                    `;
                    document.body.appendChild(status);
                }
                this.connectionStatus = document.getElementById('connection-status');
            }

            createProgressIndicator() {
                // Create progress indicator
                if (!document.getElementById('progress-indicator')) {
                    const progress = document.createElement('div');
                    progress.id = 'progress-indicator';
                    progress.className = 'progress-indicator hidden';
                    progress.innerHTML = '<div class="progress-indicator-bar"></div>';
                    document.body.appendChild(progress);
                }
                this.progressIndicator = document.getElementById('progress-indicator');
            }

            setupGlobalErrorHandling() {
                // Handle unhandled promise rejections
                window.addEventListener('unhandledrejection', (event) => {
                    console.error('Unhandled promise rejection:', event.reason);
                    this.showError('An unexpected error occurred. Please try refreshing the page.', 'error');
                });

                // Handle JavaScript errors
                window.addEventListener('error', (event) => {
                    console.error('JavaScript error:', event.error);
                    this.showError('A technical error occurred. Please try refreshing the page.', 'error');
                });

                // Handle network status changes
                window.addEventListener('online', () => {
                    this.updateConnectionStatus('online');
                    this.showError('Connection restored', 'success', 3000);
                });

                window.addEventListener('offline', () => {
                    this.updateConnectionStatus('offline');
                    this.showError('Connection lost. Working in offline mode.', 'warning', 0);
                });
            }

            showError(message, type = 'error', duration = 5000, options = {}) {
                const errorElement = document.createElement('div');
                errorElement.className = `error-message ${type}`;

                const content = document.createElement('div');
                content.className = 'error-message-content';
                content.textContent = message;

                const closeButton = document.createElement('button');
                closeButton.className = 'error-message-close';
                closeButton.innerHTML = '';
                closeButton.setAttribute('aria-label', 'Close message');
                closeButton.onclick = () => this.removeError(errorElement);

                errorElement.appendChild(content);
                errorElement.appendChild(closeButton);

                // Add retry button if specified
                if (options.showRetry && options.onRetry) {
                    const retryButton = document.createElement('button');
                    retryButton.className = 'retry-button';
                    retryButton.innerHTML = ' Retry';
                    retryButton.onclick = () => {
                        options.onRetry();
                        this.removeError(errorElement);
                    };
                    content.appendChild(document.createElement('br'));
                    content.appendChild(retryButton);
                }

                this.errorContainer.appendChild(errorElement);

                // Auto-remove after duration (0 means persistent)
                if (duration > 0) {
                    setTimeout(() => this.removeError(errorElement), duration);
                }

                return errorElement;
            }

            showPartialDataWarning(missingData) {
                const warningElement = document.createElement('div');
                warningElement.className = 'partial-data-warning';
                warningElement.innerHTML = `
                    <div class="partial-data-warning-icon"></div>
                    <div class="partial-data-warning-content">
                        <div class="partial-data-warning-title">Partial Data Available</div>
                        <div class="partial-data-warning-text">
                            Some data is missing or incomplete: ${missingData.join(', ')}. 
                            Displaying available information.
                        </div>
                    </div>
                `;
                return warningElement;
            }

            createEmptyState(title, description, actionText = null, onAction = null) {
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-state';

                let actionButton = '';
                if (actionText && onAction) {
                    actionButton = `<button class="empty-state-action" onclick="(${onAction.toString()})()">${actionText}</button>`;
                }

                emptyState.innerHTML = `
                    <div class="empty-state-icon">
                        <svg viewBox="0 0 64 64" fill="currentColor">
                            <path d="M32 8C18.7 8 8 18.7 8 32s10.7 24 24 24 24-10.7 24-24S45.3 8 32 8zm0 44c-11 0-20-9-20-20s9-20 20-20 20 9 20 20-9 20-20 20z"/>
                            <path d="M32 16c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2s2-.9 2-2V18c0-1.1-.9-2-2-2z"/>
                            <circle cx="32" cy="42" r="2"/>
                        </svg>
                    </div>
                    <div class="empty-state-title">${title}</div>
                    <div class="empty-state-description">${description}</div>
                    ${actionButton}
                `;

                return emptyState;
            }

            createLoadingState(message = 'Loading data...') {
                const loadingState = document.createElement('div');
                loadingState.className = 'loading-state';
                loadingState.innerHTML = `
                    <div class="loading-spinner-large"></div>
                    <div class="loading-text">${message}</div>
                `;
                return loadingState;
            }

            showProgress(show = true, indeterminate = true) {
                if (show) {
                    this.progressIndicator.classList.remove('hidden');
                    const bar = this.progressIndicator.querySelector('.progress-indicator-bar');
                    if (indeterminate) {
                        bar.classList.add('indeterminate');
                    } else {
                        bar.classList.remove('indeterminate');
                    }
                } else {
                    this.progressIndicator.classList.add('hidden');
                }
            }

            updateProgress(percentage) {
                const bar = this.progressIndicator.querySelector('.progress-indicator-bar');
                bar.classList.remove('indeterminate');
                bar.style.width = `${Math.min(100, Math.max(0, percentage))}%`;
            }

            updateConnectionStatus(status) {
                if (!this.connectionStatus) return;

                this.connectionStatus.className = `connection-status ${status}`;

                const statusText = {
                    online: 'Connected',
                    offline: 'Offline',
                    reconnecting: 'Reconnecting...'
                };

                this.connectionStatus.querySelector('span').textContent = statusText[status] || status;
            }

            removeError(errorElement) {
                if (errorElement && errorElement.parentNode) {
                    errorElement.classList.add('fade-out');
                    setTimeout(() => {
                        if (errorElement.parentNode) {
                            errorElement.parentNode.removeChild(errorElement);
                        }
                    }, 300);
                }
            }

            clearAllErrors() {
                if (this.errorContainer) {
                    this.errorContainer.innerHTML = '';
                }
            }

            // Graceful degradation helpers
            handlePartialDataScenario(data, expectedFields) {
                const missingFields = [];
                const availableData = {};

                expectedFields.forEach(field => {
                    if (!data[field] || (Array.isArray(data[field]) && data[field].length === 0)) {
                        missingFields.push(field);
                    } else {
                        availableData[field] = data[field];
                    }
                });

                if (missingFields.length > 0) {
                    const warning = this.showPartialDataWarning(missingFields);
                    return { availableData, warning, hasMissingData: true };
                }

                return { availableData: data, warning: null, hasMissingData: false };
            }

            // Error recovery suggestions
            getRecoverySuggestions(error) {
                const suggestions = {
                    'NETWORK_ERROR': [
                        'Check your internet connection',
                        'Try refreshing the page',
                        'Contact your network administrator if the problem persists'
                    ],
                    'HTTP_ERROR': [
                        'Verify your API credentials',
                        'Check if the Google Sheet is accessible',
                        'Ensure the sheet is shared with the service account'
                    ],
                    'DATA_FORMAT_ERROR': [
                        'Check the spreadsheet column structure',
                        'Ensure all required columns are present',
                        'Verify data format matches expectations'
                    ],
                    'INSUFFICIENT_DATA': [
                        'Add survey data to the spreadsheet',
                        'Check if the correct sheet tab is selected',
                        'Verify the data range configuration'
                    ]
                };

                return suggestions[error.type] || [
                    'Try refreshing the page',
                    'Check your internet connection',
                    'Contact support if the problem continues'
                ];
            }
        }

        // Initialize managers
        const cacheManager = new DataCacheManager(CACHE_CONFIG);
        const errorManager = new ErrorDisplayManager();

        // Auto-refresh functionality
        class AutoRefreshManager {
            constructor(cacheManager, interval = 30000) {
                this.cacheManager = cacheManager;
                this.interval = interval;
                this.refreshTimer = null;
                this.isActive = false;
            }

            start() {
                if (this.isActive) return;

                this.isActive = true;
                this.refreshTimer = setInterval(async () => {
                    try {
                        // Only refresh if cache is expired and not currently loading
                        if (!this.cacheManager.isCacheValid() && !dataCache.isLoading) {
                            await this.cacheManager.getData(true);
                            // Trigger UI update without flickering
                            this.updateUIIntelligently();
                        }
                    } catch (error) {
                        // Silent refresh failures - errors are handled by cache manager
                        console.debug('Auto-refresh failed:', error.message);
                    }
                }, this.interval);
            }

            stop() {
                if (this.refreshTimer) {
                    clearInterval(this.refreshTimer);
                    this.refreshTimer = null;
                }
                this.isActive = false;
            }

            /**
             * Update UI without causing flickering
             */
            updateUIIntelligently() {
                // Only update if the page is visible and user is not actively interacting
                if (document.hidden || document.activeElement !== document.body) {
                    return;
                }

                // Dispatch custom event for UI components to handle updates
                const updateEvent = new CustomEvent('dataRefreshed', {
                    detail: { data: dataCache.data, timestamp: dataCache.timestamp }
                });
                document.dispatchEvent(updateEvent);
            }
        }

        // Initialize auto-refresh
        const autoRefreshManager = new AutoRefreshManager(cacheManager, CACHE_CONFIG.duration);

        // Enhanced Public API for accessing data
        window.DashboardAPI = {
            /**
             * Get survey data with comprehensive error handling
             */
            async getData(forceRefresh = false, showProgress = true) {
                try {
                    if (showProgress) {
                        errorManager.showProgress(true);
                    }

                    const data = await cacheManager.getData(forceRefresh);

                    if (showProgress) {
                        errorManager.showProgress(false);
                    }

                    // Validate data quality
                    const validation = this.validateDataQuality(data);
                    if (validation.hasIssues) {
                        this.handleDataQualityIssues(validation);
                    }

                    return data;
                } catch (error) {
                    if (showProgress) {
                        errorManager.showProgress(false);
                    }

                    // Don't show duplicate error messages - let the cache manager handle it
                    if (!error.handledByCache) {
                        errorManager.showError(this.getErrorMessage(error), 'error', 8000, {
                            showRetry: true,
                            onRetry: () => this.getData(forceRefresh, showProgress)
                        });
                    }

                    throw error;
                }
            },

            /**
             * Validate data quality and completeness
             */
            validateDataQuality(data) {
                const issues = [];
                const warnings = [];

                if (!data || !Array.isArray(data)) {
                    issues.push('Invalid data format');
                    return { hasIssues: true, issues, warnings };
                }

                if (data.length === 0) {
                    issues.push('No survey data available');
                    return { hasIssues: true, issues, warnings };
                }

                // Check for missing critical fields
                const criticalFields = ['companyName', 'overallSatisfaction', 'accountManager'];
                const missingCriticalData = data.filter(item =>
                    criticalFields.some(field => !item[field])
                );

                if (missingCriticalData.length > 0) {
                    warnings.push(`${missingCriticalData.length} surveys missing critical information`);
                }

                // Do not warn about incomplete surveys; we treat submittedAt as completion source of truth

                return {
                    hasIssues: issues.length > 0 || warnings.length > 0,
                    issues,
                    warnings,
                    totalRecords: data.length,
                    completeRecords: data.filter(item => item.submittedAt).length
                };
            },

            /**
             * Handle data quality issues with user feedback
             */
            handleDataQualityIssues(validation) {
                if (validation.issues.length > 0) {
                    validation.issues.forEach(issue => {
                        errorManager.showError(issue, 'error');
                    });
                }

                // Data quality warnings are now suppressed to provide a cleaner user experience
                // Internal validation still occurs for system reliability
                if (validation.warnings.length > 0) {
                    // Log warnings for debugging but don't display to users
                    console.log('Data quality validation warnings:', validation.warnings);
                }
            },



            /**
             * Get cache status with enhanced information
             */
            getCacheStatus() {
                return {
                    hasData: Boolean(dataCache.data),
                    isValid: cacheManager.isCacheValid(),
                    isLoading: dataCache.isLoading,
                    lastUpdated: dataCache.timestamp,
                    retryCount: dataCache.retryCount,
                    nextRefresh: dataCache.timestamp ? new Date(dataCache.timestamp + CACHE_CONFIG.duration) : null,
                    isOnline: navigator.onLine,
                    recordCount: dataCache.data ? dataCache.data.length : 0
                };
            },

            /**
             * Manual refresh with user feedback
             */
            async refresh() {
                try {
                    errorManager.clearAllErrors();
                    errorManager.showError('Refreshing data...', 'info', 2000);

                    const data = await this.getData(true);

                    errorManager.showError('Data refreshed successfully', 'success', 3000);
                    return data;
                } catch (error) {
                    errorManager.showError('Failed to refresh data', 'error');
                    throw error;
                }
            },

            /**
             * Start/stop auto-refresh with status updates
             */
            startAutoRefresh() {
                autoRefreshManager.start();
                errorManager.showError('Auto-refresh enabled', 'info', 2000);
            },

            stopAutoRefresh() {
                autoRefreshManager.stop();
                errorManager.showError('Auto-refresh disabled', 'info', 2000);
            },

            /**
             * Handle offline scenarios
             */
            handleOfflineMode() {
                if (!navigator.onLine && dataCache.data) {
                    errorManager.showError('Working offline with cached data', 'warning', 0);
                    return dataCache.data;
                }
                return null;
            },

            /**
             * Get comprehensive error message with context
             */
            getErrorMessage(error) {
                const baseMessages = {
                    'NETWORK_ERROR': 'Connection issue. Please check your internet connection and try again.',
                    'HTTP_ERROR': this.getHTTPErrorMessage(error.statusCode),
                    'DATA_FORMAT_ERROR': 'Data format error. Please check your spreadsheet structure.',
                    'INSUFFICIENT_DATA': 'No survey data found. Please ensure your spreadsheet contains data.',
                    'AUTHENTICATION_ERROR': 'Authentication failed. Please check your API credentials.',
                    'RATE_LIMIT_ERROR': 'Too many requests. Please wait before trying again.',
                    'TIMEOUT_ERROR': 'Request timed out. Please check your connection and try again.'
                };

                return baseMessages[error.type] || 'An unexpected error occurred. Please try refreshing the page.';
            },

            /**
             * Get specific HTTP error messages
             */
            getHTTPErrorMessage(statusCode) {
                const httpMessages = {
                    400: 'Bad request. Please check your configuration.',
                    401: 'Unauthorized. Please check your API credentials.',
                    403: 'Access denied. Please verify your permissions.',
                    404: 'Spreadsheet not found. Please verify the spreadsheet ID.',
                    429: 'Rate limit exceeded. Please wait before trying again.',
                    500: 'Server error. Please try again later.',
                    502: 'Service temporarily unavailable. Please try again later.',
                    503: 'Service unavailable. Please try again later.'
                };

                return httpMessages[statusCode] || `Server error (${statusCode}). Please try again later.`;
            },

            /**
             * Emergency data recovery
             */
            async emergencyRecovery() {
                try {
                    // Try to get any cached data
                    if (dataCache.data) {
                        errorManager.showError('Using cached data due to connection issues', 'warning');
                        return dataCache.data;
                    }

                    // Try offline mode
                    const offlineData = this.handleOfflineMode();
                    if (offlineData) {
                        return offlineData;
                    }

                    // Last resort: return empty state
                    throw new Error('No data available for recovery');
                } catch (error) {
                    errorManager.showError('Unable to recover data. Please refresh the page.', 'error');
                    throw error;
                }
            }
        };

        // Error Recovery System
        class ErrorRecoverySystem {
            constructor() {
                this.recoveryStrategies = {
                    'NETWORK_ERROR': this.handleNetworkError.bind(this),
                    'HTTP_ERROR': this.handleHTTPError.bind(this),
                    'DATA_FORMAT_ERROR': this.handleDataFormatError.bind(this),
                    'INSUFFICIENT_DATA': this.handleInsufficientData.bind(this),
                    'AUTHENTICATION_ERROR': this.handleAuthError.bind(this),
                    'RATE_LIMIT_ERROR': this.handleRateLimitError.bind(this)
                };

                this.setupGlobalErrorRecovery();
            }

            setupGlobalErrorRecovery() {
                // Listen for critical errors
                document.addEventListener('criticalError', (event) => {
                    this.handleCriticalError(event.detail);
                });

                // Monitor connection status
                this.monitorConnectionHealth();
            }

            async handleCriticalError(error) {
                const strategy = this.recoveryStrategies[error.type];
                if (strategy) {
                    await strategy(error);
                } else {
                    await this.handleGenericError(error);
                }
            }

            async handleNetworkError(error) {
                // Try to use cached data
                const offlineData = window.DashboardAPI.handleOfflineMode();
                if (offlineData) {
                    errorManager.showError('Using cached data while offline', 'warning', 5000);
                    return offlineData;
                }

                // Schedule periodic retry
                this.schedulePeriodicRetry();
                return null;
            }

            async handleHTTPError(error) {
                if (error.statusCode === 429) {
                    // Rate limiting - wait and retry
                    const waitTime = this.calculateBackoffDelay();
                    errorManager.showError(`Rate limited. Retrying in ${waitTime / 1000} seconds...`, 'warning', waitTime);

                    setTimeout(() => {
                        window.DashboardAPI.refresh();
                    }, waitTime);
                } else if (error.statusCode >= 500) {
                    // Server error - try emergency recovery
                    return await window.DashboardAPI.emergencyRecovery();
                }
            }

            async handleDataFormatError(error) {
                // Try to recover partial data
                try {
                    const rawData = await window.DashboardAPI.getData(true, false);
                    const processor = new SurveyDataProcessor();
                    const cleanedData = processor.parseAndValidateSurveyData(rawData);

                    if (cleanedData.length > 0) {
                        errorManager.showError('Some data was recovered despite format issues', 'warning', 5000);
                        return cleanedData;
                    }
                } catch (recoveryError) {
                    console.error('Data recovery failed:', recoveryError);
                }

                return null;
            }

            async handleInsufficientData(error) {
                // Check if it's a configuration issue
                errorManager.showError(
                    'No data found. Please verify your spreadsheet configuration.',
                    'error',
                    0,
                    {
                        showRetry: true,
                        onRetry: () => window.DashboardAPI.refresh()
                    }
                );
            }

            async handleAuthError(error) {
                errorManager.showError(
                    'Authentication failed. Please check your API credentials and permissions.',
                    'error',
                    0
                );
            }

            async handleRateLimitError(error) {
                const backoffTime = this.calculateBackoffDelay();
                errorManager.showError(
                    `Rate limit exceeded. Automatically retrying in ${backoffTime / 1000} seconds...`,
                    'warning',
                    backoffTime
                );

                setTimeout(() => {
                    window.DashboardAPI.refresh();
                }, backoffTime);
            }

            async handleGenericError(error) {
                // Last resort recovery
                try {
                    return await window.DashboardAPI.emergencyRecovery();
                } catch (recoveryError) {
                    errorManager.showError(
                        'Critical error occurred. Please refresh the page.',
                        'error',
                        0,
                        {
                            showRetry: true,
                            onRetry: () => window.location.reload()
                        }
                    );
                }
            }

            calculateBackoffDelay() {
                const baseDelay = 5000; // 5 seconds
                const maxDelay = 60000; // 1 minute
                const retryCount = dataCache.retryCount || 0;

                return Math.min(baseDelay * Math.pow(2, retryCount), maxDelay);
            }

            schedulePeriodicRetry() {
                const retryInterval = 30000; // 30 seconds

                const retryTimer = setInterval(async () => {
                    if (navigator.onLine) {
                        try {
                            await window.DashboardAPI.refresh();
                            clearInterval(retryTimer);
                            errorManager.showError('Connection restored', 'success', 3000);
                        } catch (error) {
                            console.debug('Periodic retry failed:', error.message);
                        }
                    }
                }, retryInterval);
            }

            monitorConnectionHealth() {
                setInterval(() => {
                    const cacheStatus = window.DashboardAPI.getCacheStatus();

                    // Check if data is stale
                    if (cacheStatus.lastUpdated) {
                        const staleThreshold = 5 * 60 * 1000; // 5 minutes
                        const dataAge = Date.now() - cacheStatus.lastUpdated;

                        if (dataAge > staleThreshold && navigator.onLine) {
                            errorManager.showError('Data may be outdated. Refreshing...', 'info', 3000);
                            window.DashboardAPI.refresh().catch(error => {
                                console.debug('Health check refresh failed:', error.message);
                            });
                        }
                    }
                }, 60000); // Check every minute
            }
        }

        // Initialize error recovery system
        const errorRecoverySystem = new ErrorRecoverySystem();

        // Add CSS animations for error messages
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInRight {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            
            @keyframes slideOutRight {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(100%);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);

        // Enhanced Application Initialization
        class ApplicationInitializer {
            constructor() {
                this.initializationSteps = [
                    { name: 'API Setup', progress: 10 },
                    { name: 'Loading Configuration', progress: 25 },
                    { name: 'Connecting to Data Source', progress: 50 },
                    { name: 'Processing Data', progress: 75 },
                    { name: 'Rendering Interface', progress: 90 },
                    { name: 'Complete', progress: 100 }
                ];
                this.currentStep = 0;
            }

            async initialize() {
                try {
                    errorManager.showProgress(true, false);

                    // Step 1: API Setup
                    this.updateProgress(0);
                    await this.delay(200);

                    // Step 2: Loading Configuration
                    this.updateProgress(1);
                    await this.delay(200);

                    // Step 3: Connecting to Data Source
                    this.updateProgress(2);

                    // Start auto-refresh
                    autoRefreshManager.start();

                    // Step 4: Processing Data
                    this.updateProgress(3);

                    // Initial data load with progress tracking
                    const data = await window.DashboardAPI.getData(false, false);

                    // Step 5: Rendering Interface
                    this.updateProgress(4);
                    await this.delay(300);

                    // Step 6: Complete
                    this.updateProgress(5);
                    await this.delay(200);

                    errorManager.showProgress(false);
                    errorManager.showError('Dashboard loaded successfully', 'success', 3000);

                    console.log('Application initialized successfully');

                } catch (error) {
                    errorManager.showProgress(false);
                    console.error('Failed to initialize application:', error.message);

                    // Show initialization error with recovery options
                    errorManager.showError(
                        'Failed to initialize dashboard. Please check your connection and try again.',
                        'error',
                        0,
                        {
                            showRetry: true,
                            onRetry: () => this.initialize()
                        }
                    );
                }
            }

            updateProgress(stepIndex) {
                if (stepIndex < this.initializationSteps.length) {
                    const step = this.initializationSteps[stepIndex];
                    errorManager.updateProgress(step.progress);
                    this.currentStep = stepIndex;
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // ===================================================================
        // Accessibility and Performance Enhancements
        // ===================================================================

        /**
         * Accessibility Manager
         * Handles keyboard navigation, screen reader announcements, and focus management
         */
        class AccessibilityManager {
            constructor() {
                this.liveRegion = null;
                this.keyboardNavigationActive = false;
                this.focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
                this.init();
            }

            init() {
                this.setupLiveRegion();
                this.setupKeyboardNavigation();
                this.setupFocusManagement();
                this.setupTabNavigation();
                this.setupAccordionAccessibility();
                this.setupTableAccessibility();
            }

            /**
             * Set up live region for screen reader announcements
             */
            setupLiveRegion() {
                this.liveRegion = document.getElementById('live-region');
                if (!this.liveRegion) {
                    this.liveRegion = document.createElement('div');
                    this.liveRegion.id = 'live-region';
                    this.liveRegion.className = 'sr-only';
                    this.liveRegion.setAttribute('aria-live', 'polite');
                    this.liveRegion.setAttribute('aria-atomic', 'true');
                    document.body.appendChild(this.liveRegion);
                }
            }

            /**
             * Announce message to screen readers
             */
            announce(message, priority = 'polite') {
                if (!this.liveRegion) return;

                this.liveRegion.setAttribute('aria-live', priority);
                this.liveRegion.textContent = message;

                // Clear after announcement
                setTimeout(() => {
                    this.liveRegion.textContent = '';
                }, 1000);
            }

            /**
             * Set up keyboard navigation detection
             */
            setupKeyboardNavigation() {
                // Detect keyboard navigation
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        this.keyboardNavigationActive = true;
                        document.body.classList.add('keyboard-navigation-active');
                    }
                });

                document.addEventListener('mousedown', () => {
                    this.keyboardNavigationActive = false;
                    document.body.classList.remove('keyboard-navigation-active');
                });

                // Arrow key navigation for tabs
                document.addEventListener('keydown', (e) => {
                    if (e.target.matches('.nav-tab')) {
                        this.handleTabKeyNavigation(e);
                    }
                });
            }

            /**
             * Handle arrow key navigation for tabs
             */
            handleTabKeyNavigation(e) {
                const tabs = Array.from(document.querySelectorAll('.nav-tab'));
                const currentIndex = tabs.indexOf(e.target);
                let nextIndex;

                switch (e.key) {
                    case 'ArrowLeft':
                    case 'ArrowUp':
                        e.preventDefault();
                        nextIndex = currentIndex > 0 ? currentIndex - 1 : tabs.length - 1;
                        tabs[nextIndex].focus();
                        break;
                    case 'ArrowRight':
                    case 'ArrowDown':
                        e.preventDefault();
                        nextIndex = currentIndex < tabs.length - 1 ? currentIndex + 1 : 0;
                        tabs[nextIndex].focus();
                        break;
                    case 'Home':
                        e.preventDefault();
                        tabs[0].focus();
                        break;
                    case 'End':
                        e.preventDefault();
                        tabs[tabs.length - 1].focus();
                        break;
                }
            }

            /**
             * Set up focus management for tab panels
             */
            setupFocusManagement() {
                // Focus main content when tab changes
                document.addEventListener('click', (e) => {
                    if (e.target.matches('.nav-tab')) {
                        setTimeout(() => {
                            const mainContent = document.getElementById('main-content');
                            if (mainContent) {
                                mainContent.focus();
                            }
                        }, 100);
                    }
                });
            }

            /**
             * Set up tab navigation accessibility
             */
            setupTabNavigation() {
                const tabs = document.querySelectorAll('.nav-tab');
                const panels = document.querySelectorAll('.content-section');

                tabs.forEach((tab, index) => {
                    tab.addEventListener('click', () => {
                        // Update ARIA attributes
                        tabs.forEach(t => t.setAttribute('aria-selected', 'false'));
                        panels.forEach(p => p.setAttribute('aria-hidden', 'true'));

                        tab.setAttribute('aria-selected', 'true');
                        const targetPanel = document.getElementById(tab.getAttribute('aria-controls'));
                        if (targetPanel) {
                            targetPanel.setAttribute('aria-hidden', 'false');
                        }

                        // Announce tab change
                        this.announce(`Switched to ${tab.textContent} section`);
                    });
                });
            }

            /**
             * Set up accordion accessibility
             */
            setupAccordionAccessibility() {
                document.addEventListener('click', (e) => {
                    if (e.target.matches('.accordion-header') || e.target.closest('.accordion-header')) {
                        const header = e.target.matches('.accordion-header') ? e.target : e.target.closest('.accordion-header');
                        const card = header.closest('.accordion-card');
                        const isExpanded = card.classList.contains('expanded');

                        // Update ARIA attributes
                        header.setAttribute('aria-expanded', !isExpanded);

                        // Announce state change
                        const customerName = header.querySelector('.accordion-title')?.textContent || 'Survey';
                        this.announce(`${customerName} ${isExpanded ? 'collapsed' : 'expanded'}`);
                    }
                });
            }

            /**
             * Set up table accessibility
             */
            setupTableAccessibility() {
                // Add row navigation
                document.addEventListener('keydown', (e) => {
                    if (e.target.matches('td, th')) {
                        this.handleTableNavigation(e);
                    }
                });

                // Announce table updates
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.target.matches('tbody')) {
                            const table = mutation.target.closest('table');
                            const rows = table.querySelectorAll('tbody tr');
                            if (rows.length > 0 && !rows[0].textContent.includes('Loading')) {
                                const tableName = table.getAttribute('aria-labelledby');
                                const heading = document.getElementById(tableName);
                                if (heading) {
                                    this.announce(`${heading.textContent} updated with ${rows.length} items`);
                                }
                            }
                        }
                    });
                });

                document.querySelectorAll('tbody').forEach(tbody => {
                    observer.observe(tbody, { childList: true, subtree: true });
                });
            }

            /**
             * Handle table keyboard navigation
             */
            handleTableNavigation(e) {
                const cell = e.target;
                const row = cell.closest('tr');
                const table = cell.closest('table');
                const cells = Array.from(row.querySelectorAll('td, th'));
                const rows = Array.from(table.querySelectorAll('tr'));
                const currentCellIndex = cells.indexOf(cell);
                const currentRowIndex = rows.indexOf(row);

                switch (e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        if (currentCellIndex > 0) {
                            cells[currentCellIndex - 1].focus();
                        }
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        if (currentCellIndex < cells.length - 1) {
                            cells[currentCellIndex + 1].focus();
                        }
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        if (currentRowIndex > 0) {
                            const targetRow = rows[currentRowIndex - 1];
                            const targetCells = targetRow.querySelectorAll('td, th');
                            if (targetCells[currentCellIndex]) {
                                targetCells[currentCellIndex].focus();
                            }
                        }
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        if (currentRowIndex < rows.length - 1) {
                            const targetRow = rows[currentRowIndex + 1];
                            const targetCells = targetRow.querySelectorAll('td, th');
                            if (targetCells[currentCellIndex]) {
                                targetCells[currentCellIndex].focus();
                            }
                        }
                        break;
                }
            }
        }

        /**
         * Performance Manager
         * Handles optimizations for large datasets and cross-browser compatibility
         */
        class PerformanceManager {
            constructor() {
                this.virtualScrollThreshold = 100;
                this.debounceDelay = 300;
                this.init();
            }

            init() {
                this.setupVirtualScrolling();
                this.setupDebouncing();
                this.setupIntersectionObserver();
                this.setupCrossBrowserCompatibility();
            }

            /**
             * Set up virtual scrolling for large datasets
             */
            setupVirtualScrolling() {
                const tables = document.querySelectorAll('.data-table');
                tables.forEach(table => {
                    const tbody = table.querySelector('tbody');
                    if (tbody) {
                        this.enableVirtualScrolling(tbody);
                    }
                });
            }

            /**
             * Enable virtual scrolling for table body
             */
            enableVirtualScrolling(tbody) {
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'childList') {
                            const rows = tbody.querySelectorAll('tr');
                            if (rows.length > this.virtualScrollThreshold) {
                                this.implementVirtualScrolling(tbody, rows);
                            }
                        }
                    });
                });

                observer.observe(tbody, { childList: true });
            }

            /**
             * Implement virtual scrolling for large row sets
             */
            implementVirtualScrolling(tbody, rows) {
                const container = tbody.closest('.data-table-container');
                if (!container || container.classList.contains('virtual-scroll-enabled')) return;

                container.classList.add('virtual-scroll-enabled');

                // Create virtual scroll container
                const virtualContainer = document.createElement('div');
                virtualContainer.className = 'virtual-scroll-container';

                const virtualContent = document.createElement('div');
                virtualContent.className = 'virtual-scroll-content';

                // Move table into virtual container
                const table = tbody.closest('table');
                container.insertBefore(virtualContainer, table);
                virtualContainer.appendChild(virtualContent);
                virtualContent.appendChild(table);

                // Implement virtual scrolling logic
                this.setupVirtualScrollLogic(virtualContainer, tbody, rows);
            }

            /**
             * Set up virtual scroll logic
             */
            setupVirtualScrollLogic(container, tbody, rows) {
                const rowHeight = 60; // Approximate row height
                const visibleRows = Math.ceil(container.clientHeight / rowHeight) + 5; // Buffer
                let startIndex = 0;

                const updateVisibleRows = () => {
                    const scrollTop = container.scrollTop;
                    startIndex = Math.floor(scrollTop / rowHeight);
                    const endIndex = Math.min(startIndex + visibleRows, rows.length);

                    // Clear tbody
                    tbody.innerHTML = '';

                    // Add visible rows
                    for (let i = startIndex; i < endIndex; i++) {
                        if (rows[i]) {
                            tbody.appendChild(rows[i].cloneNode(true));
                        }
                    }

                    // Update scroll height
                    const totalHeight = rows.length * rowHeight;
                    tbody.style.paddingTop = `${startIndex * rowHeight}px`;
                    tbody.style.paddingBottom = `${(rows.length - endIndex) * rowHeight}px`;
                };

                container.addEventListener('scroll', this.debounce(updateVisibleRows, 16)); // 60fps
                updateVisibleRows(); // Initial render
            }

            /**
             * Set up debouncing for performance
             */
            setupDebouncing() {
                // Debounce resize events
                window.addEventListener('resize', this.debounce(() => {
                    this.handleResize();
                }, this.debounceDelay));

                // Debounce search/filter operations
                document.addEventListener('input', (e) => {
                    if (e.target.matches('[data-search]')) {
                        this.debounce(() => {
                            this.handleSearch(e.target);
                        }, this.debounceDelay)();
                    }
                });
            }

            /**
             * Debounce utility function
             */
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            /**
             * Handle window resize
             */
            handleResize() {
                // Recalculate virtual scroll containers
                const virtualContainers = document.querySelectorAll('.virtual-scroll-container');
                virtualContainers.forEach(container => {
                    // Trigger recalculation
                    container.dispatchEvent(new Event('scroll'));
                });
            }

            /**
             * Set up Intersection Observer for lazy loading
             */
            setupIntersectionObserver() {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const element = entry.target;
                            if (element.dataset.lazyLoad) {
                                this.loadContent(element);
                                observer.unobserve(element);
                            }
                        }
                    });
                }, {
                    rootMargin: '50px'
                });

                // Observe lazy-loadable elements
                document.querySelectorAll('[data-lazy-load]').forEach(el => {
                    observer.observe(el);
                });
            }

            /**
             * Load content for lazy-loaded elements
             */
            loadContent(element) {
                const contentType = element.dataset.lazyLoad;
                switch (contentType) {
                    case 'chart':
                        this.loadChart(element);
                        break;
                    case 'table':
                        this.loadTable(element);
                        break;
                    default:
                        console.warn('Unknown lazy load content type:', contentType);
                }
            }

            /**
             * Set up cross-browser compatibility
             */
            setupCrossBrowserCompatibility() {
                // Polyfill for CSS custom properties in IE
                if (!window.CSS || !CSS.supports('color', 'var(--test)')) {
                    this.polyfillCSSCustomProperties();
                }

                // Polyfill for IntersectionObserver
                if (!window.IntersectionObserver) {
                    this.loadIntersectionObserverPolyfill();
                }

                // Fix for Safari focus issues
                if (navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome')) {
                    this.fixSafariFocusIssues();
                }

                // Fix for IE11 grid issues
                if (navigator.userAgent.includes('Trident')) {
                    this.fixIE11GridIssues();
                }
            }

            /**
             * Polyfill CSS custom properties for IE
             */
            polyfillCSSCustomProperties() {
                // Simple fallback for critical custom properties
                const fallbackStyles = `
                    .nav-tab:focus { outline: 2px solid #1f6a4a; }
                    .accordion-header:focus { outline: 2px solid #1f6a4a; }
                    .table-cell-link:focus { outline: 2px solid #1f6a4a; }
                `;

                const style = document.createElement('style');
                style.textContent = fallbackStyles;
                document.head.appendChild(style);
            }

            /**
             * Fix Safari focus issues
             */
            fixSafariFocusIssues() {
                // Make buttons focusable in Safari
                document.querySelectorAll('button').forEach(button => {
                    if (!button.hasAttribute('tabindex')) {
                        button.setAttribute('tabindex', '0');
                    }
                });
            }

            /**
             * Fix IE11 grid issues
             */
            fixIE11GridIssues() {
                // Add flexbox fallback for IE11
                const ie11Styles = `
                    .metrics-grid { display: flex; flex-wrap: wrap; }
                    .metrics-grid > * { flex: 1; min-width: 300px; }
                `;

                const style = document.createElement('style');
                style.textContent = ie11Styles;
                document.head.appendChild(style);
            }
        }

        // Initialize accessibility and performance managers
        let accessibilityManager;
        let performanceManager;

        // Expose managers globally for debugging and external access
        window.accessibilityManager = null;
        window.performanceManager = null;

        // Initialize application on page load
        document.addEventListener('DOMContentLoaded', () => {
            const appInitializer = new ApplicationInitializer();
            appInitializer.initialize();

            // Initialize accessibility and performance enhancements
            accessibilityManager = new AccessibilityManager();
            performanceManager = new PerformanceManager();

            // Expose globally
            window.accessibilityManager = accessibilityManager;
            window.performanceManager = performanceManager;

            // Announce page load completion
            setTimeout(() => {
                accessibilityManager.announce('Dashboard loaded and ready for use');
            }, 1000);
        });

        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                autoRefreshManager.stop();
            } else {
                autoRefreshManager.start();
                // Refresh data when page becomes visible again
                window.DashboardAPI.getData(true).catch(error => {
                    console.debug('Visibility refresh failed:', error.message);
                });
            }
        });

        // ===================================================================
        // Data Processing and Calculation Functions
        // ===================================================================

        /**
         * Survey Response Data Processing Class
         * Handles parsing, validation, and calculation of survey metrics
         */
        class SurveyDataProcessor {
            constructor() {
                // Service type mapping to normalize variations
                this.serviceTypeMapping = {
                    // English variations
                    'Last Mile Only': 'Last Mile Only',
                    'Fulfilment Only': 'Fulfillment Only',
                    'Fulfillment Only': 'Fulfillment Only',
                    'Last Mile & Fulfilment': 'Last Mile & Fulfillment',
                    'Last Mile & Fulfillment': 'Last Mile & Fulfillment',

                    // Arabic variations
                    ' ': 'Last Mile Only',
                    ' ': 'Last Mile & Fulfillment',
                    ' ': 'Fulfillment Only'
                };

                this.validServiceTypes = ['Last Mile Only', 'Fulfillment Only', 'Last Mile & Fulfillment'];

                // Account manager name mapping to normalize variations
                this.accountManagerMapping = {
                    'Ibrahim Fadaly': 'Ibrahim Fadaly',
                    'Ahmed Saleem': 'Ahmed Saleem',
                    'Ahmed Salem': 'Ahmed Saleem',
                    ' ': 'Ahmed Saleem',
                    ' ': 'Ahmed Saleem',
                    'Ahmed saleem': 'Ahmed Saleem',
                    'Abdullah Ahmed': 'Abdullah Ahmed',
                    ' ': 'Abdullah Ahmed',
                    ' ': 'Abdullah Ahmed',
                    '  ': 'Abdullah Ahmed',
                    '  ': 'Abdullah Ahmed',
                    '  ': 'Abdullah Al Owlaqi',
                    'Abdullah Al Owlaqi': 'Abdullah Al Owlaqi',
                    '': 'Joanna',
                    'Joanna': 'Joanna',
                    // Remove invalid managers for Q3
                    ' ': 'Ahmed Saleem', // Map to Ahmed Saleem instead
                    'Amjad Aljowair': 'Ahmed Saleem', // Map to Ahmed Saleem instead
                    'Starlinks': 'Ahmed Saleem', // Map to Ahmed Saleem instead
                    'Starlinks Team': 'Ahmed Saleem' // Map to Ahmed Saleem instead
                };

                this.validAccountManagers = ['Ibrahim Fadaly', 'Ahmed Saleem', 'Abdullah Ahmed'];
            }

            /**
             * Normalize service type to standard format
             */
            normalizeServiceType(serviceType) {
                if (!serviceType) return null;

                const normalized = this.serviceTypeMapping[serviceType.trim()];
                return normalized || serviceType.trim();
            }

            /**
             * Normalize account manager name to standard format
             */
            normalizeAccountManager(accountManager) {
                if (!accountManager) return null;

                const normalized = this.accountManagerMapping[accountManager.trim()];
                return normalized || accountManager.trim();
            }

            /**
             * Parse and validate survey response data
             * Requirements: 2.2, 8.2
             */
            parseAndValidateSurveyData(rawData) {
                if (!Array.isArray(rawData)) {
                    throw new Error('Survey data must be an array');
                }

                const validatedData = rawData.map((response, index) => {
                    try {
                        return this.validateSurveyResponse(response, index);
                    } catch (error) {
                        console.warn(`Validation error for survey ${index + 1}:`, error.message);
                        return null;
                    }
                }).filter(response => response !== null);

                return validatedData;
            }

            /**
             * Validate individual survey response
             * Requirements: 8.2
             */
            validateSurveyResponse(response, index) {
                const validated = { ...response };

                // Validate required fields
                if (!validated.companyName || typeof validated.companyName !== 'string') {
                    throw new Error(`Invalid company name at row ${index + 1}`);
                }

                // Validate service type
                if (validated.serviceType && !this.validServiceTypes.includes(validated.serviceType)) {
                    console.warn(`Unknown service type "${validated.serviceType}" at row ${index + 1}, keeping as-is`);
                }

                // Validate rating fields (1-5 scale)
                const ratingFields = [
                    'overallSatisfaction', 'lastMileSatisfaction', 'reverseDeliverySatisfaction',
                    'fulfillmentSatisfaction', 'communicationClarity', 'responsiveness',
                    'problemResolution', 'customizationAbility', 'systemsSatisfaction', 'itSupportSatisfaction'
                ];

                ratingFields.forEach(field => {
                    if (validated[field] !== null && validated[field] !== undefined) {
                        const value = Number(validated[field]);
                        if (isNaN(value) || value < 1 || value > 5) {
                            console.warn(`Invalid ${field} rating "${validated[field]}" at row ${index + 1}, setting to null`);
                            validated[field] = null;
                        } else {
                            validated[field] = value;
                        }
                    }
                });

                // Validate NPS score (1-10 scale)
                if (validated.npsScore !== null && validated.npsScore !== undefined) {
                    const npsValue = Number(validated.npsScore);
                    if (isNaN(npsValue) || npsValue < 1 || npsValue > 10) {
                        console.warn(`Invalid NPS score "${validated.npsScore}" at row ${index + 1}, setting to null`);
                        validated.npsScore = null;
                    } else {
                        validated.npsScore = npsValue;
                    }
                }

                // Validate account manager
                if (validated.accountManager && !this.validAccountManagers.includes(validated.accountManager)) {
                    console.warn(`Unknown account manager "${validated.accountManager}" at row ${index + 1}, keeping as-is`);
                }

                // Validate submission date
                if (validated.submittedAt && !(validated.submittedAt instanceof Date)) {
                    const date = new Date(validated.submittedAt);
                    if (isNaN(date.getTime())) {
                        console.warn(`Invalid submission date "${validated.submittedAt}" at row ${index + 1}, setting to null`);
                        validated.submittedAt = null;
                        validated.isCompleted = false;
                    } else {
                        validated.submittedAt = date;
                        validated.isCompleted = true;
                    }
                }

                return validated;
            }

            /**
             * Calculate completion rates and satisfaction percentages
             * Requirements: 3.1, 3.2
             */
            calculateOverallMetrics(surveyData) {
                console.log('calculateOverallMetrics called with', surveyData.length, 'surveys');

                const totalSurveysIncludingPending = surveyData.length; // 114 (69 + 45)
                // Treat any survey with a valid submittedAt as completed
                const completedSurveys = surveyData.filter(survey => !!survey.submittedAt).length; // 69
                const pendingSurveys = totalSurveysIncludingPending - completedSurveys; // 45

                // For display: show only completed surveys as "Total Surveys"
                const totalSurveysForDisplay = completedSurveys; // 69

                console.log('Total surveys (including pending):', totalSurveysIncludingPending, 'Completed:', completedSurveys, 'Pending:', pendingSurveys);
                console.log('Total surveys for display:', totalSurveysForDisplay);

                // Calculate completion percentage using full count (including pending)
                const completionPercentage = totalSurveysIncludingPending > 0 ? Math.round((completedSurveys / totalSurveysIncludingPending) * 100) : 0;
                console.log('Completion percentage:', completionPercentage);

                // Calculate satisfied customers (ratings 4-5)
                const satisfiedCustomers = surveyData.filter(survey =>
                    survey.submittedAt && survey.overallSatisfaction >= 4
                ).length;

                console.log('Satisfied customers (rating 4-5):', satisfiedCustomers);

                const satisfiedCustomersPercentage = completedSurveys > 0
                    ? Math.round((satisfiedCustomers / completedSurveys) * 100)
                    : 0;

                console.log('Satisfied customers percentage:', satisfiedCustomersPercentage);

                // Calculate average satisfaction rating
                const completedWithRatings = surveyData.filter(survey =>
                    survey.submittedAt && survey.overallSatisfaction !== null
                );

                const averageSatisfaction = completedWithRatings.length > 0
                    ? completedWithRatings.reduce((sum, survey) => sum + survey.overallSatisfaction, 0) / completedWithRatings.length
                    : 0;

                return {
                    totalSurveys: totalSurveysForDisplay, // Show 69 (completed responses)
                    completedSurveys,
                    pendingSurveys,
                    completionPercentage, // Calculated using 69/114
                    satisfiedCustomers,
                    satisfiedCustomersPercentage,
                    averageSatisfaction: Math.round(averageSatisfaction * 10) / 10, // Round to 1 decimal
                    totalSurveysIncludingPending // Keep this for internal use if needed
                };
            }

            /**
             * Calculate product type breakdown for service types
             * Requirements: 3.3
             */
            calculateProductTypeBreakdown(surveyData) {
                const breakdown = {
                    'Last Mile Only': { completed: 0, satisfied: 0, total: 0 },
                    'Fulfillment Only': { completed: 0, satisfied: 0, total: 0 },
                    'Last Mile & Fulfillment': { completed: 0, satisfied: 0, total: 0 }
                };

                surveyData.forEach(survey => {
                    const serviceType = survey.serviceType;

                    if (breakdown[serviceType]) {
                        breakdown[serviceType].total++;

                        if (survey.submittedAt) {
                            breakdown[serviceType].completed++;

                            if (survey.overallSatisfaction >= 4) {
                                breakdown[serviceType].satisfied++;
                            }
                        }
                    }
                });

                // Calculate percentages for each service type
                Object.keys(breakdown).forEach(serviceType => {
                    const data = breakdown[serviceType];
                    data.completionRate = data.total > 0 ? Math.round((data.completed / data.total) * 100) : 0;
                    data.satisfactionRate = data.completed > 0 ? Math.round((data.satisfied / data.completed) * 100) : 0;
                });

                return breakdown;
            }

            /**
             * Calculate account manager performance metrics
             * Requirements: 6.2, 6.4
             */
            calculateAccountManagerMetrics(surveyData) {
                const managerMetrics = {};

                // Initialize metrics for known managers
                this.validAccountManagers.forEach(manager => {
                    managerMetrics[manager] = {
                        name: manager,
                        totalAssigned: 0,
                        completed: 0,
                        pending: 0,
                        satisfied: 0,
                        completionRate: 0,
                        satisfactionRate: 0
                    };
                });

                // Process survey data
                surveyData.forEach(survey => {
                    const manager = survey.accountManager;

                    if (manager) {
                        // Initialize manager if not in known list (dynamic detection)
                        if (!managerMetrics[manager]) {
                            managerMetrics[manager] = {
                                name: manager,
                                totalAssigned: 0,
                                completed: 0,
                                pending: 0,
                                satisfied: 0,
                                completionRate: 0,
                                satisfactionRate: 0
                            };
                        }

                        const metrics = managerMetrics[manager];
                        metrics.totalAssigned++;

                        if (survey.submittedAt) {
                            metrics.completed++;

                            if (survey.overallSatisfaction >= 4) {
                                metrics.satisfied++;
                            }
                        } else {
                            metrics.pending++;
                        }
                    }
                });

                // Calculate percentages for each manager
                Object.keys(managerMetrics).forEach(manager => {
                    const metrics = managerMetrics[manager];

                    metrics.completionRate = metrics.totalAssigned > 0
                        ? Math.round((metrics.completed / metrics.totalAssigned) * 100 * 10) / 10
                        : 0;

                    metrics.satisfactionRate = metrics.completed > 0
                        ? Math.round((metrics.satisfied / metrics.completed) * 100 * 10) / 10
                        : 0;
                });

                return managerMetrics;
            }

            /**
             * Get completed surveys sorted by completion date
             * Requirements: 4.2, 4.6
             */
            getCompletedSurveys(surveyData) {
                return surveyData
                    .filter(survey => survey.submittedAt)
                    .sort((a, b) => {
                        // Sort by completion date (most recent first)
                        if (!a.submittedAt && !b.submittedAt) return 0;
                        if (!a.submittedAt) return 1;
                        if (!b.submittedAt) return -1;
                        return b.submittedAt.getTime() - a.submittedAt.getTime();
                    });
            }

            /**
             * Get pending surveys sorted alphabetically by customer name
             * Requirements: 4.3, 4.7
             */
            getPendingSurveys(surveyData) {
                return surveyData
                    .filter(survey => !survey.submittedAt)
                    .sort((a, b) => {
                        // Sort alphabetically by company name
                        return a.companyName.localeCompare(b.companyName);
                    });
            }

            /**
             * Format survey data for accordion display
             * Requirements: 5.1, 5.2, 5.3
             */
            formatSurveyForAccordion(survey) {
                const formatDate = (date) => {
                    if (!date) return 'Not completed';
                    return date.toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric'
                    });
                };

                const getRatingColor = (rating) => {
                    if (rating >= 4) return 'excellent';
                    if (rating === 3) return 'average';
                    if (rating >= 1) return 'poor';
                    return 'unknown';
                };

                const formatRating = (rating) => {
                    return rating !== null && rating !== undefined ? `${rating}/5` : 'N/A';
                };

                return {
                    id: survey.id,
                    companyName: survey.companyName,
                    completionDate: formatDate(survey.submittedAt),
                    overallRating: survey.overallSatisfaction,
                    ratingColor: getRatingColor(survey.overallSatisfaction),
                    formattedRating: formatRating(survey.overallSatisfaction),
                    accountManager: survey.accountManager || 'Not assigned',
                    serviceType: survey.serviceType || 'Not specified',
                    questions: [
                        { label: 'Overall Satisfaction', answer: formatRating(survey.overallSatisfaction) },
                        { label: 'NPS Score', answer: survey.npsScore ? `${survey.npsScore}/10` : 'N/A' },
                        { label: 'Last Mile Satisfaction', answer: formatRating(survey.lastMileSatisfaction) },
                        { label: 'Reverse Delivery Satisfaction', answer: formatRating(survey.reverseDeliverySatisfaction) },
                        { label: 'Fulfillment Satisfaction', answer: formatRating(survey.fulfillmentSatisfaction) },
                        { label: 'Communication Clarity', answer: formatRating(survey.communicationClarity) },
                        { label: 'Responsiveness', answer: formatRating(survey.responsiveness) },
                        { label: 'Problem Resolution', answer: formatRating(survey.problemResolution) },
                        { label: 'Customization Ability', answer: formatRating(survey.customizationAbility) },
                        { label: 'Systems Satisfaction', answer: formatRating(survey.systemsSatisfaction) },
                        { label: 'IT Support Satisfaction', answer: formatRating(survey.itSupportSatisfaction) },
                        { label: 'Suggestions', answer: survey.suggestions || 'No suggestions provided' }
                    ]
                };
            }

            /**
             * Handle missing or invalid data gracefully
             * Requirements: 8.2
             */
            handleMissingData(data, fieldName, defaultValue = null) {
                if (data === null || data === undefined || data === '') {
                    return defaultValue;
                }
                return data;
            }

            /**
             * Validate data integrity across all surveys
             * Requirements: 8.2
             */
            validateDataIntegrity(surveyData) {
                const issues = [];

                surveyData.forEach((survey, index) => {
                    // Check for missing critical fields
                    if (!survey.companyName) {
                        issues.push(`Survey ${index + 1}: Missing company name`);
                    }

                    // Treat submittedAt as source of truth; do not flag mismatches

                    // Check for inconsistent ratings
                    if (survey.overallSatisfaction && (survey.overallSatisfaction < 1 || survey.overallSatisfaction > 5)) {
                        issues.push(`Survey ${index + 1}: Overall satisfaction rating out of range (${survey.overallSatisfaction})`);
                    }
                });

                return {
                    isValid: issues.length === 0,
                    issues: issues,
                    totalSurveys: surveyData.length,
                    validSurveys: surveyData.length - issues.length
                };
            }
        }

        /**
         * Metric Calculation Utilities
         * Helper functions for specific metric calculations
         */
        class MetricCalculator {
            /**
             * Calculate percentage with proper rounding
             */
            static calculatePercentage(numerator, denominator, decimalPlaces = 0) {
                if (denominator === 0) return 0;
                const percentage = (numerator / denominator) * 100;
                return Math.round(percentage * Math.pow(10, decimalPlaces)) / Math.pow(10, decimalPlaces);
            }

            /**
             * Calculate average rating with validation
             */
            static calculateAverageRating(ratings, decimalPlaces = 1) {
                const validRatings = ratings.filter(rating =>
                    rating !== null && rating !== undefined && !isNaN(rating)
                );

                if (validRatings.length === 0) return 0;

                const average = validRatings.reduce((sum, rating) => sum + rating, 0) / validRatings.length;
                return Math.round(average * Math.pow(10, decimalPlaces)) / Math.pow(10, decimalPlaces);
            }

            /**
             * Count satisfied customers (ratings 4-5)
             */
            static countSatisfiedCustomers(surveys) {
                return surveys.filter(survey =>
                    survey.submittedAt &&
                    survey.overallSatisfaction !== null &&
                    survey.overallSatisfaction >= 4
                ).length;
            }

            /**
             * Group surveys by field value
             */
            static groupSurveysByField(surveys, fieldName) {
                const groups = {};

                surveys.forEach(survey => {
                    const value = survey[fieldName] || 'Unknown';
                    if (!groups[value]) {
                        groups[value] = [];
                    }
                    groups[value].push(survey);
                });

                return groups;
            }
        }

        // Initialize data processor
        const surveyDataProcessor = new SurveyDataProcessor();

        // Add data processing methods to the public API
        window.DashboardAPI.DataProcessor = {
            /**
             * Process raw survey data and return calculated metrics
             */
            async processData(forceRefresh = false) {
                try {
                    const rawData = await window.DashboardAPI.getData(forceRefresh);
                    const validatedData = surveyDataProcessor.parseAndValidateSurveyData(rawData);

                    return {
                        rawData: validatedData,
                        overallMetrics: surveyDataProcessor.calculateOverallMetrics(validatedData),
                        productTypeBreakdown: surveyDataProcessor.calculateProductTypeBreakdown(validatedData),
                        accountManagerMetrics: surveyDataProcessor.calculateAccountManagerMetrics(validatedData),
                        completedSurveys: surveyDataProcessor.getCompletedSurveys(validatedData),
                        pendingSurveys: surveyDataProcessor.getPendingSurveys(validatedData),
                        dataIntegrity: surveyDataProcessor.validateDataIntegrity(validatedData)
                    };
                } catch (error) {
                    console.error('Data processing error:', error);
                    throw error;
                }
            },

            /**
             * Get formatted survey data for accordion display
             */
            formatSurveyForDisplay(survey) {
                return surveyDataProcessor.formatSurveyForAccordion(survey);
            },

            /**
             * Validate survey data integrity
             */
            validateData(surveyData) {
                return surveyDataProcessor.validateDataIntegrity(surveyData);
            },

            /**
             * Access to metric calculator utilities
             */
            MetricCalculator: MetricCalculator
        };

    </script>
    <!-- Skip to main content link for accessibility -->
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <!-- Live region for screen reader announcements -->
    <div id="live-region" class="sr-only" aria-live="polite" aria-atomic="true"></div>

    <!-- Password Protection Overlay -->
    <div id="password-protection" class="password-overlay">
        <div class="password-container">
            <form id="password-form" class="password-form">
                <div class="logo-section">
                    <img src="logo.png" alt="Company Logo" class="password-logo">
                    <span class="password-logo-text">Dashboard</span>
                </div>
                <h1 class="password-title">Protected Page</h1>
                <div class="input-group">
                    <label for="password-input" class="password-label">Please Enter Your Password</label>
                    <input type="password" id="password-input" class="password-input" placeholder="Enter password" required aria-describedby="error-message">
                    <button type="submit" class="password-submit">Submit</button>
                </div>
                <div id="error-message" class="error-message hidden" role="alert" aria-live="polite"></div>
            </form>
        </div>
    </div>

    <div class="dashboard-container hidden">
        <!-- Header Section -->
        <header class="header" role="banner">
            <div class="header-content">
                <div class="logo">
                    <img src="logo.png" alt="Customer Satisfaction Dashboard" class="logo-image">
                    <span class="logo-text sr-only">Dashboard</span>
                </div>

                <nav class="navigation" role="tablist" aria-label="Dashboard sections">
                    <button class="nav-tab active" data-tab="csat-summary" role="tab" aria-selected="true"
                        aria-controls="csat-summary-panel" id="tab-csat-summary">
                        CSAT Summary
                    </button>
                    <button class="nav-tab" data-tab="customer-status" role="tab" aria-selected="false"
                        aria-controls="customer-status-panel" id="tab-customer-status">
                        Customer Status
                    </button>
                    <button class="nav-tab" data-tab="completed-surveys" role="tab" aria-selected="false"
                        aria-controls="completed-surveys-panel" id="tab-completed-surveys">
                        Completed Surveys
                    </button>
                    <button class="nav-tab" data-tab="account-manager-performance" role="tab" aria-selected="false"
                        aria-controls="account-manager-performance-panel" id="tab-account-manager-performance">
                        Account Manager Performance
                    </button>
                </nav>

                <div class="quarter-filter">
                    <label for="quarter-select" class="quarter-filter-label">Quarter:</label>
                    <div style="position: relative;">
                        <select id="quarter-select" class="quarter-filter-select" aria-label="Filter by quarter">
                            <option value="all">All Quarters</option>
                            <option value="q1">Q1 2025</option>
                            <option value="q2">Q2 2025</option>
                            <option value="q3">Q3 2025</option>
                            <option value="q4">Q4 2025</option>
                        </select>
                        <svg class="quarter-filter-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7">
                            </path>
                        </svg>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main Content Area -->
        <main class="main-content" id="main-content" tabindex="-1">
            <!-- CSAT Summary Section -->
            <section id="csat-summary-panel" class="content-section active" role="tabpanel"
                aria-labelledby="tab-csat-summary" aria-hidden="false">
                <div class="content-grid">
                    <h1 class="heading-lg mb-lg">Customer Satisfaction Summary</h1>

                    <!-- Loading State -->
                    <div id="csat-loading" class="metrics-grid" style="display: none;">
                        <div class="skeleton-card">
                            <div class="skeleton skeleton-text title"></div>
                            <div class="skeleton skeleton-metric"></div>
                            <div class="skeleton skeleton-text"></div>
                        </div>
                        <div class="skeleton-card">
                            <div class="skeleton skeleton-text title"></div>
                            <div class="skeleton skeleton-metric"></div>
                            <div class="skeleton skeleton-text"></div>
                            <div class="skeleton skeleton-progress"></div>
                        </div>
                        <div class="skeleton-card">
                            <div class="skeleton skeleton-text title"></div>
                            <div class="skeleton skeleton-metric"></div>
                            <div class="skeleton skeleton-text"></div>
                            <div class="skeleton skeleton-progress"></div>
                        </div>
                    </div>

                    <!-- Main Metrics Grid -->
                    <div id="csat-metrics" class="metrics-grid">
                        <!-- Total Surveys Card -->
                        <div class="metric-card">
                            <div class="metric-card-header">
                                <span class="metric-card-title">Total Surveys</span>
                            </div>
                            <div id="total-surveys-value" class="metric-value large">0</div>
                            <div class="metric-label">Survey Responses</div>
                        </div>

                        <!-- Completion Rate Card -->
                        <div class="metric-card">
                            <div class="metric-card-header">
                                <span class="metric-card-title">Completion Rate</span>
                            </div>
                            <div id="completion-rate-value" class="metric-value success">0%</div>
                            <div class="metric-label">Response Rate</div>
                            <div class="progress-container">
                                <div class="progress-bar">
                                    <div id="completion-rate-progress" class="progress-fill success" style="width: 0%">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Satisfaction Rate Card -->
                        <div class="metric-card">
                            <div class="metric-card-header">
                                <span class="metric-card-title">Satisfaction Rate</span>
                            </div>
                            <div id="satisfaction-rate-value" class="metric-value">0%</div>
                            <div class="metric-label">Customers Rating 4-5</div>
                            <div class="progress-container">
                                <div class="progress-bar">
                                    <div id="satisfaction-rate-progress" class="progress-fill" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Product Type Breakdown -->
                    <div class="mt-lg">
                        <h2 class="heading-md mb-lg">Service Type Breakdown</h2>

                        <!-- Loading State for Product Breakdown -->
                        <div id="product-breakdown-loading" class="three-column-grid" style="display: none;">
                            <div class="skeleton-card">
                                <div class="skeleton skeleton-text title"></div>
                                <div class="skeleton skeleton-metric"></div>
                                <div class="skeleton skeleton-text"></div>
                                <div class="skeleton skeleton-progress"></div>
                            </div>
                            <div class="skeleton-card">
                                <div class="skeleton skeleton-text title"></div>
                                <div class="skeleton skeleton-metric"></div>
                                <div class="skeleton skeleton-text"></div>
                                <div class="skeleton skeleton-progress"></div>
                            </div>
                            <div class="skeleton-card">
                                <div class="skeleton skeleton-text title"></div>
                                <div class="skeleton skeleton-metric"></div>
                                <div class="skeleton skeleton-text"></div>
                                <div class="skeleton skeleton-progress"></div>
                            </div>
                        </div>

                        <!-- Product Type Cards -->
                        <div id="product-breakdown" class="three-column-grid">
                            <!-- Last Mile Only Card -->
                            <div class="metric-card">
                                <div class="metric-card-header">
                                    <span class="metric-card-title">Last Mile Only</span>
                                </div>
                                <div id="lastmile-surveys-value" class="metric-value">0</div>
                                <div class="metric-label">Completed Surveys</div>

                                <div class="progress-container">
                                    <div class="progress-label">
                                        <span class="progress-label-text">Completion Rate</span>
                                        <span id="lastmile-completion-rate" class="progress-label-value">0%</span>
                                    </div>
                                    <div class="progress-bar">
                                        <div id="lastmile-completion-progress" class="progress-fill" style="width: 0%">
                                        </div>
                                    </div>
                                </div>

                                <div class="progress-container">
                                    <div class="progress-label">
                                        <span class="progress-label-text">Satisfaction Rate</span>
                                        <span id="lastmile-satisfaction-rate" class="progress-label-value">0%</span>
                                    </div>
                                    <div class="progress-bar">
                                        <div id="lastmile-satisfaction-progress" class="progress-fill"
                                            style="width: 0%"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Fulfillment Only Card -->
                            <div class="metric-card">
                                <div class="metric-card-header">
                                    <span class="metric-card-title">Fulfillment Only</span>
                                </div>
                                <div id="fulfillment-surveys-value" class="metric-value">0</div>
                                <div class="metric-label">Completed Surveys</div>

                                <div class="progress-container">
                                    <div class="progress-label">
                                        <span class="progress-label-text">Completion Rate</span>
                                        <span id="fulfillment-completion-rate" class="progress-label-value">0%</span>
                                    </div>
                                    <div class="progress-bar">
                                        <div id="fulfillment-completion-progress" class="progress-fill"
                                            style="width: 0%"></div>
                                    </div>
                                </div>

                                <div class="progress-container">
                                    <div class="progress-label">
                                        <span class="progress-label-text">Satisfaction Rate</span>
                                        <span id="fulfillment-satisfaction-rate" class="progress-label-value">0%</span>
                                    </div>
                                    <div class="progress-bar">
                                        <div id="fulfillment-satisfaction-progress" class="progress-fill"
                                            style="width: 0%"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Last Mile & Fulfillment Card -->
                            <div class="metric-card">
                                <div class="metric-card-header">
                                    <span class="metric-card-title">Last Mile & Fulfillment</span>
                                </div>
                                <div id="combined-surveys-value" class="metric-value">0</div>
                                <div class="metric-label">Completed Surveys</div>

                                <div class="progress-container">
                                    <div class="progress-label">
                                        <span class="progress-label-text">Completion Rate</span>
                                        <span id="combined-completion-rate" class="progress-label-value">0%</span>
                                    </div>
                                    <div class="progress-bar">
                                        <div id="combined-completion-progress" class="progress-fill" style="width: 0%">
                                        </div>
                                    </div>
                                </div>

                                <div class="progress-container">
                                    <div class="progress-label">
                                        <span class="progress-label-text">Satisfaction Rate</span>
                                        <span id="combined-satisfaction-rate" class="progress-label-value">0%</span>
                                    </div>
                                    <div class="progress-bar">
                                        <div id="combined-satisfaction-progress" class="progress-fill"
                                            style="width: 0%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Customer Status Section -->
            <section id="customer-status-panel" class="content-section" role="tabpanel"
                aria-labelledby="tab-customer-status" aria-hidden="true">
                <div class="content-grid">
                    <h1 class="heading-lg mb-lg">Customer Status</h1>

                    <!-- Loading State -->
                    <div id="customer-status-loading" class="two-column-grid" style="display: none;">
                        <div class="data-table-container">
                            <h2 class="heading-md"
                                style="padding: var(--spacing-lg); margin: 0; border-bottom: 1px solid var(--primary-border);">
                                Completed Surveys</h2>
                            <div style="padding: var(--spacing-lg);">
                                <div class="skeleton skeleton-table-row"></div>
                                <div class="skeleton skeleton-table-row"></div>
                                <div class="skeleton skeleton-table-row"></div>
                            </div>
                        </div>
                        <div class="data-table-container">
                            <h2 class="heading-md"
                                style="padding: var(--spacing-lg); margin: 0; border-bottom: 1px solid var(--primary-border);">
                                Pending Surveys</h2>
                            <div style="padding: var(--spacing-lg);">
                                <div class="skeleton skeleton-table-row"></div>
                                <div class="skeleton skeleton-table-row"></div>
                                <div class="skeleton skeleton-table-row"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Customer Status Tables -->
                    <div id="customer-status-tables" class="two-column-grid">
                        <!-- Completed Surveys Table -->
                        <div class="data-table-container">
                            <h2 class="heading-md"
                                style="padding: var(--spacing-lg); margin: 0; border-bottom: 1px solid var(--primary-border);"
                                id="completed-surveys-heading">
                                Completed Surveys</h2>
                            <table id="completed-surveys-table" class="data-table" role="table"
                                aria-labelledby="completed-surveys-heading"
                                aria-describedby="completed-surveys-description">
                                <caption id="completed-surveys-description" class="sr-only">
                                    Table showing customers who have completed satisfaction surveys, with completion
                                    dates and assigned account managers. Click customer names to view detailed
                                    responses.
                                </caption>
                                <thead>
                                    <tr role="row">
                                        <th role="columnheader" scope="col" aria-sort="none">Customer Name</th>
                                        <th role="columnheader" scope="col" aria-sort="none">Account Manager</th>
                                        <th role="columnheader" scope="col" aria-sort="descending">Completion Date</th>
                                        <th role="columnheader" scope="col" aria-sort="none">Status</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <!-- Data will be populated dynamically -->
                                    <tr>
                                        <td colspan="4"
                                            style="text-align: center; padding: var(--spacing-xl); color: #666;"
                                            role="status" aria-live="polite">
                                            Loading customer data...
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- Pending Surveys Table -->
                        <div class="data-table-container">
                            <h2 class="heading-md"
                                style="padding: var(--spacing-lg); margin: 0; border-bottom: 1px solid var(--primary-border);"
                                id="pending-surveys-heading">
                                Pending Surveys</h2>
                            <table id="pending-surveys-table" class="data-table" role="table"
                                aria-labelledby="pending-surveys-heading"
                                aria-describedby="pending-surveys-description">
                                <caption id="pending-surveys-description" class="sr-only">
                                    Table showing customers with pending satisfaction surveys and their assigned account
                                    managers. Sorted alphabetically by customer name.
                                </caption>
                                <thead>
                                    <tr role="row">
                                        <th role="columnheader" scope="col" aria-sort="ascending">Customer Name</th>
                                        <th role="columnheader" scope="col" aria-sort="none">Account Manager</th>
                                        <th role="columnheader" scope="col" aria-sort="none">Status</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <!-- Data will be populated dynamically -->
                                    <tr>
                                        <td colspan="3"
                                            style="text-align: center; padding: var(--spacing-xl); color: #666;"
                                            role="status" aria-live="polite">
                                            Loading customer data...
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>


                </div>
            </section>

            <!-- Completed Surveys Section -->
            <section id="completed-surveys-panel" class="content-section" role="tabpanel"
                aria-labelledby="tab-completed-surveys" aria-hidden="true">
                <div class="content-grid">
                    <h1 class="heading-lg mb-lg">Completed Surveys</h1>
                    <div class="full-width-grid">
                        <!-- Dynamic Accordion Interface for Survey Details -->
                        <div id="completed-surveys-accordion" class="accordion-container">
                            <!-- Accordion cards will be dynamically populated here -->
                        </div>
                    </div>
                </div>
            </section>

            <!-- Account Manager Performance Section -->
            <section id="account-manager-performance-panel" class="content-section" role="tabpanel"
                aria-labelledby="tab-account-manager-performance" aria-hidden="true">
                <div class="content-grid">
                    <h1 class="heading-lg mb-lg">Account Manager Performance</h1>

                    <!-- Loading State -->
                    <div id="account-manager-loading" class="three-column-grid" style="display: none;">
                        <div class="skeleton-card">
                            <div class="skeleton skeleton-text title"></div>
                            <div class="skeleton skeleton-metric"></div>
                            <div class="skeleton skeleton-text"></div>
                            <div class="skeleton skeleton-progress"></div>
                            <div class="skeleton skeleton-progress"></div>
                        </div>
                        <div class="skeleton-card">
                            <div class="skeleton skeleton-text title"></div>
                            <div class="skeleton skeleton-metric"></div>
                            <div class="skeleton skeleton-text"></div>
                            <div class="skeleton skeleton-progress"></div>
                            <div class="skeleton skeleton-progress"></div>
                        </div>
                        <div class="skeleton-card">
                            <div class="skeleton skeleton-text title"></div>
                            <div class="skeleton skeleton-metric"></div>
                            <div class="skeleton skeleton-text"></div>
                            <div class="skeleton skeleton-progress"></div>
                            <div class="skeleton skeleton-progress"></div>
                        </div>
                    </div>

                    <!-- Account Manager Performance Cards -->
                    <div id="account-manager-cards" class="three-column-grid">
                        <!-- Dynamic cards will be populated here -->
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        // Basic tab navigation functionality for foundation
        document.addEventListener('DOMContentLoaded', function () {
            const tabs = document.querySelectorAll('.nav-tab');
            const sections = document.querySelectorAll('.content-section');

            // Load active tab from sessionStorage
            const activeTab = sessionStorage.getItem('activeTab') || 'csat-summary';
            showTab(activeTab);

            tabs.forEach(tab => {
                tab.addEventListener('click', function () {
                    const tabId = this.getAttribute('data-tab');
                    showTab(tabId);
                    sessionStorage.setItem('activeTab', tabId);
                });

                // Keyboard navigation
                tab.addEventListener('keydown', function (e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.click();
                    }
                });
            });

            function showTab(tabId) {
                // Update tab states
                tabs.forEach(tab => {
                    const isActive = tab.getAttribute('data-tab') === tabId;
                    tab.classList.toggle('active', isActive);
                });

                // Update section visibility
                sections.forEach(section => {
                    const isActive = section.id === tabId + '-panel';
                    section.classList.toggle('active', isActive);
                });

                // Smooth scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });

                // Re-apply the current quarter filter whenever switching tabs
                try {
                    if (window.quarterFilter && typeof window.quarterFilter.filterAndRefreshData === 'function') {
                        console.log('Re-applying quarter filter on tab switch to:', tabId);
                        window.quarterFilter.filterAndRefreshData();
                    }
                } catch (e) {
                    console.warn('Failed to re-apply quarter filter on basic tab switch:', e);
                }
            }
        });

        // Tab Navigation System
        class TabNavigationSystem {
            constructor() {
                this.tabs = document.querySelectorAll('.nav-tab');
                this.panels = document.querySelectorAll('.content-section');
                this.activeTabKey = 'starlinks-dashboard-active-tab';

                this.init();
            }

            init() {
                // Set up event listeners
                this.tabs.forEach((tab, index) => {
                    tab.addEventListener('click', (e) => this.handleTabClick(e));
                    tab.addEventListener('keydown', (e) => this.handleKeyNavigation(e, index));
                });

                // Restore active tab from sessionStorage
                this.restoreActiveTab();

                // Set up smooth scrolling behavior
                this.setupSmoothScrolling();
            }

            handleTabClick(event) {
                event.preventDefault();
                const clickedTab = event.target;
                const targetPanel = clickedTab.getAttribute('data-tab');

                this.switchToTab(targetPanel);
                this.saveActiveTab(targetPanel);
                this.smoothScrollToTop();
            }

            handleKeyNavigation(event, currentIndex) {
                let targetIndex = currentIndex;

                switch (event.key) {
                    case 'ArrowLeft':
                        event.preventDefault();
                        targetIndex = currentIndex > 0 ? currentIndex - 1 : this.tabs.length - 1;
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        targetIndex = currentIndex < this.tabs.length - 1 ? currentIndex + 1 : 0;
                        break;
                    case 'Home':
                        event.preventDefault();
                        targetIndex = 0;
                        break;
                    case 'End':
                        event.preventDefault();
                        targetIndex = this.tabs.length - 1;
                        break;
                    case 'Enter':
                    case ' ':
                        event.preventDefault();
                        this.tabs[currentIndex].click();
                        return;
                    default:
                        return;
                }

                // Focus and activate the target tab
                this.tabs[targetIndex].focus();
                const targetPanel = this.tabs[targetIndex].getAttribute('data-tab');
                this.switchToTab(targetPanel);
                this.saveActiveTab(targetPanel);
            }

            switchToTab(targetPanelId) {
                // Update tab states
                this.tabs.forEach(tab => {
                    const isActive = tab.getAttribute('data-tab') === targetPanelId;
                    tab.classList.toggle('active', isActive);
                });

                // Update panel visibility
                this.panels.forEach(panel => {
                    const isActive = panel.id === targetPanelId + '-panel';
                    panel.classList.toggle('active', isActive);


                });

                // Re-apply current quarter filter when switching tabs
                try {
                    if (window.quarterFilter && typeof window.quarterFilter.filterAndRefreshData === 'function') {
                        console.log('Re-applying quarter filter on tab switch to:', targetPanelId);
                        // Always re-apply the filter, regardless of the current quarter value
                        window.quarterFilter.filterAndRefreshData();
                    }
                } catch (e) {
                    console.warn('Failed to re-apply quarter filter on tab switch:', e);
                }
            }

            saveActiveTab(tabId) {
                try {
                    sessionStorage.setItem(this.activeTabKey, tabId);
                } catch (error) {
                    console.warn('Could not save active tab to sessionStorage:', error);
                }
            }

            restoreActiveTab() {
                try {
                    const savedTab = sessionStorage.getItem(this.activeTabKey);
                    if (savedTab) {
                        // Check if the saved tab exists
                        const tabExists = Array.from(this.tabs).some(tab =>
                            tab.getAttribute('data-tab') === savedTab
                        );

                        if (tabExists) {
                            this.switchToTab(savedTab);
                            return;
                        }
                    }
                } catch (error) {
                    console.warn('Could not restore active tab from sessionStorage:', error);
                }

                // Fallback to first tab if no saved tab or error
                if (this.tabs.length > 0) {
                    const firstTabId = this.tabs[0].getAttribute('data-tab');
                    this.switchToTab(firstTabId);
                }
            }

            setupSmoothScrolling() {
                // Enable smooth scrolling for the entire document
                document.documentElement.style.scrollBehavior = 'smooth';
            }

            smoothScrollToTop() {
                // Smooth scroll to top when switching tabs
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            }
        }

        // Demo function for loading overlay
        function simulateDataLoad() {
            const button = event.target;
            const section = button.closest('section');

            // Create loading overlay
            const overlay = document.createElement('div');
            overlay.className = 'loading-overlay';
            overlay.innerHTML = '<div class="loading-spinner"></div>';

            // Position overlay relative to section
            section.style.position = 'relative';
            section.appendChild(overlay);

            // Remove overlay after 3 seconds
            setTimeout(() => {
                if (overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                }
                section.style.position = '';
            }, 3000);
        }

        // Enhanced UI Error Handling and Empty States Manager
        class UIErrorHandler {
            constructor() {
                this.emptyStateTemplates = {
                    noData: {
                        title: 'No Data Available',
                        description: 'There is currently no survey data to display. Please check your data source or try refreshing the page.',
                        actionText: 'Refresh Data',
                        actionCallback: () => window.DashboardAPI.refresh()
                    },
                    noCompletedSurveys: {
                        title: 'No Completed Surveys',
                        description: 'No customers have completed their satisfaction surveys yet. Check back later or contact customers to complete their surveys.',
                        actionText: null,
                        actionCallback: null
                    },
                    noPendingSurveys: {
                        title: 'No Pending Surveys',
                        description: 'All customers have completed their surveys. Great job on the follow-up!',
                        actionText: null,
                        actionCallback: null
                    },
                    connectionError: {
                        title: 'Connection Error',
                        description: 'Unable to connect to the data source. Please check your internet connection and try again.',
                        actionText: 'Retry Connection',
                        actionCallback: () => window.DashboardAPI.refresh()
                    },
                    loadingError: {
                        title: 'Loading Error',
                        description: 'There was an error loading the data. This might be a temporary issue.',
                        actionText: 'Try Again',
                        actionCallback: () => window.location.reload()
                    }
                };
            }

            /**
             * Create and display empty state
             */
            createEmptyState(container, type, customOptions = {}) {
                if (!container) return null;

                const template = this.emptyStateTemplates[type] || this.emptyStateTemplates.noData;
                const options = { ...template, ...customOptions };

                const emptyStateElement = errorManager.createEmptyState(
                    options.title,
                    options.description,
                    options.actionText,
                    options.actionCallback
                );

                // Clear container and add empty state
                container.innerHTML = '';
                container.appendChild(emptyStateElement);

                return emptyStateElement;
            }

            /**
             * Create loading state for containers
             */
            createLoadingState(container, message = 'Loading...') {
                if (!container) return null;

                const loadingElement = errorManager.createLoadingState(message);
                container.innerHTML = '';
                container.appendChild(loadingElement);

                return loadingElement;
            }

            /**
             * Handle table empty states
             */
            handleTableEmptyState(tableBody, type, columnCount = 3) {
                if (!tableBody) return;

                const template = this.emptyStateTemplates[type] || this.emptyStateTemplates.noData;

                tableBody.innerHTML = `
                    <tr>
                        <td colspan="${columnCount}" style="text-align: center; padding: var(--spacing-2xl);">
                            <div class="empty-state" style="padding: var(--spacing-lg);">
                                <div class="empty-state-title">${template.title}</div>
                                <div class="empty-state-description">${template.description}</div>
                                ${template.actionText ? `
                                    <button class="empty-state-action" onclick="(${template.actionCallback.toString()})()">
                                        ${template.actionText}
                                    </button>
                                ` : ''}
                            </div>
                        </td>
                    </tr>
                `;
            }

            /**
             * Handle partial data scenarios
             */
            handlePartialData(container, availableData, missingFields) {
                if (!container) return;

                // Show partial data warning
                const warning = errorManager.showPartialDataWarning(missingFields);

                // Insert warning at the top of the container
                const firstChild = container.firstChild;
                if (firstChild) {
                    container.insertBefore(warning, firstChild);
                } else {
                    container.appendChild(warning);
                }

                return warning;
            }

            /**
             * Show error state for specific components
             */
            showComponentError(container, error, retryCallback = null) {
                if (!container) return;

                const errorMessage = window.DashboardAPI.getErrorMessage(error);

                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon" style="color: var(--error-color);">
                            <svg viewBox="0 0 64 64" fill="currentColor">
                                <path d="M32 8C18.7 8 8 18.7 8 32s10.7 24 24 24 24-10.7 24-24S45.3 8 32 8zm0 44c-11 0-20-9-20-20s9-20 20-20 20 9 20 20-9 20-20 20z"/>
                                <path d="M32 16c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2s2-.9 2-2V18c0-1.1-.9-2-2-2z"/>
                                <circle cx="32" cy="42" r="2"/>
                            </svg>
                        </div>
                        <div class="empty-state-title" style="color: var(--error-color);">Error Loading Data</div>
                        <div class="empty-state-description">${errorMessage}</div>
                        ${retryCallback ? `
                            <button class="empty-state-action" onclick="(${retryCallback.toString()})()">
                                Try Again
                            </button>
                        ` : ''}
                    </div>
                `;
            }

            /**
             * Add loading overlay to existing content
             */
            addLoadingOverlay(container) {
                if (!container) return null;

                const overlay = document.createElement('div');
                overlay.className = 'loading-overlay';
                overlay.innerHTML = '<div class="loading-spinner"></div>';

                container.style.position = 'relative';
                container.appendChild(overlay);

                return overlay;
            }

            /**
             * Remove loading overlay
             */
            removeLoadingOverlay(container) {
                if (!container) return;

                const overlay = container.querySelector('.loading-overlay');
                if (overlay) {
                    overlay.remove();
                }

                // Reset position if no other overlays
                if (!container.querySelector('.loading-overlay')) {
                    container.style.position = '';
                }
            }

            /**
             * Handle network status changes
             */
            handleNetworkStatusChange(isOnline) {
                if (!isOnline) {
                    // Show offline message
                    errorManager.showError(
                        'You are currently offline. Some features may not work properly.',
                        'warning',
                        0
                    );
                } else {
                    // Clear offline messages and refresh data
                    errorManager.clearAllErrors();
                    errorManager.showError('Connection restored. Refreshing data...', 'success', 3000);

                    // Attempt to refresh data
                    window.DashboardAPI.refresh().catch(error => {
                        console.error('Failed to refresh data after reconnection:', error);
                    });
                }
            }
        }

        // Initialize UI Error Handler
        const uiErrorHandler = new UIErrorHandler();

        // Initialize enhanced navigation system
        document.addEventListener('DOMContentLoaded', function () {
            // Initialize the enhanced tab navigation system
            new TabNavigationSystem();

            // Set up accordion accessibility
            const accordionButtons = document.querySelectorAll('.accordion-header');
            accordionButtons.forEach(button => {
                button.setAttribute('aria-expanded', 'false');
                button.setAttribute('aria-controls', button.nextElementSibling.id || '');
            });

            // Set up network status monitoring
            window.addEventListener('online', () => uiErrorHandler.handleNetworkStatusChange(true));
            window.addEventListener('offline', () => uiErrorHandler.handleNetworkStatusChange(false));
        });

        // Integration with Google Sheets API
        document.addEventListener('DOMContentLoaded', async function () {
            try {
                // Test the API integration
                console.log('Dashboard API initialized:', window.DashboardAPI);

                // Get cache status
                const cacheStatus = window.DashboardAPI.getCacheStatus();
                console.log('Cache status:', cacheStatus);

                // Test data fetching with error handling
                try {
                    console.log('Attempting to fetch real Google Sheets data...');
                    const data = await window.DashboardAPI.getData();
                    console.log('Google Sheets data loaded successfully:', data?.length || 0, 'records');

                    // Validate data structure
                    if (data && data.length > 0) {
                        const validation = window.DashboardAPI.validateDataQuality(data);
                        console.log('Data validation:', validation);

                        // Test data processing
                        const processor = new SurveyDataProcessor();
                        const metrics = processor.calculateOverallMetrics(data);
                        console.log('Calculated metrics from real data:', metrics);

                        // Debug: Check completion status
                        const completedCount = data.filter(survey => survey.submittedAt !== null).length;
                        console.log('Real data - Completed surveys:', completedCount, 'out of', data.length);
                        console.log('Sample real survey:', data[0]);

                        // Add Q3 pending customers to real data
                        const q3PendingCustomers = generateQ3PendingCustomers();
                        const realData = [...data, ...q3PendingCustomers];

                        console.log('Combined data: ', realData.length, 'total surveys');
                        console.log('Original Google Sheets data:', data.length);
                        console.log('Q3 pending customers:', q3PendingCustomers.length);

                        // Add a small delay to ensure all managers are initialized
                        setTimeout(() => {
                            console.log('About to trigger dataRefreshed event with real data:', realData.length, 'records');

                            // Debug: Analyze the real data structure after column mapping fix
                            console.log('=== REAL DATA ANALYSIS (AFTER COLUMN MAPPING FIX) ===');
                            console.log('First record structure:', realData[0]);
                            console.log('Checking submittedAt field in first 5 records:');
                            realData.slice(0, 5).forEach((record, index) => {
                                console.log(`Record ${index + 1}:`, {
                                    company: record.companyName,
                                    submittedAt: record.submittedAt,
                                    submittedAtType: typeof record.submittedAt,
                                    submittedAtValue: record.submittedAt ? record.submittedAt.toString() : 'null',
                                    isCompleted: record.isCompleted,
                                    satisfaction: record.overallSatisfaction
                                });
                            });

                            // Check how many surveys have valid submittedAt
                            const withSubmittedAt = realData.filter(survey => !!survey.submittedAt).length;
                            const withoutSubmittedAt = realData.filter(survey => !survey.submittedAt).length;
                            console.log('Surveys with submittedAt:', withSubmittedAt);
                            console.log('Surveys without submittedAt:', withoutSubmittedAt);

                            // Trigger UI updates with real data
                            document.dispatchEvent(new CustomEvent('dataRefreshed', {
                                detail: { data: realData, timestamp: Date.now() }
                            }));

                            // Also manually update CSAT summary if manager exists
                            if (window.csatSummaryManager) {
                                console.log('Manually updating CSAT summary manager with real data');
                                window.csatSummaryManager.updateSummaryMetrics(realData);
                            } else {
                                console.log('CSAT summary manager not found');
                            }
                        }, 1000);

                    } else {
                        console.log('No valid data received from Google Sheets');
                        throw new Error('No valid data from Google Sheets');
                    }
                } catch (apiError) {
                    console.log('API failed, falling back to mock data:', apiError.message);

                    // Use mock data as fallback
                    const mockData = generateMockSurveyData();
                    console.log('Using mock data fallback:', mockData.length, 'records');

                    // Add a small delay to ensure all managers are initialized
                    setTimeout(() => {
                        console.log('About to trigger dataRefreshed event with mock data:', mockData.length, 'records');

                        // Trigger UI updates with mock data
                        document.dispatchEvent(new CustomEvent('dataRefreshed', {
                            detail: { data: mockData, timestamp: Date.now() }
                        }));

                        // Also manually update CSAT summary if manager exists
                        if (window.csatSummaryManager) {
                            console.log('Manually updating CSAT summary manager with mock data');
                            window.csatSummaryManager.updateSummaryMetrics(mockData);
                        } else {
                            console.log('CSAT summary manager not found');
                        }
                    }, 1000);
                }

            } catch (error) {
                console.error('Dashboard initialization error:', error);

                // Show user-friendly error message
                errorManager.showError(
                    'Dashboard initialization failed. Some features may not work properly.',
                    'error',
                    5000
                );
            }
        });

        // Q3 Pending Customers Data
        function generateQ3PendingCustomers() {
            const q3PendingCustomers = [
                { name: 'Al Ghanem Eletronics', accountManager: 'Ahmed Saleem' },
                { name: 'Al Rajhi First Store', accountManager: 'Abdullah Ahmed' },
                { name: 'AlYasra/Ontime', accountManager: 'Ahmed Saleem' },
                { name: 'Aldo', accountManager: 'Ahmed Saleem' },
                { name: 'Amazon', accountManager: 'Ahmed Saleem' },
                { name: 'Biggbrands', accountManager: 'Ahmed Saleem' },
                { name: 'Brands for Less', accountManager: 'Ibrahim Fadaly' },
                { name: 'Call it Spring', accountManager: 'Ahmed Saleem' },
                { name: 'Claseera', accountManager: 'Ahmed Saleem' },
                { name: 'Decathlon', accountManager: 'Ahmed Saleem' },
                { name: 'DHL', accountManager: 'Ahmed Saleem' },
                { name: 'Flormar', accountManager: 'Ahmed Saleem' },
                { name: 'Golden Rose', accountManager: 'Ahmed Saleem' },
                { name: 'Homzmart', accountManager: 'Ahmed Saleem' },
                { name: 'Hopa Design', accountManager: 'Ahmed Saleem' },
                { name: 'Kabrita', accountManager: 'Abdullah Ahmed' },
                { name: 'La Senza', accountManager: 'Ahmed Saleem' },
                { name: 'Laveienrose', accountManager: 'Ahmed Saleem' },
                { name: 'Laverne UAE', accountManager: 'Abdullah Ahmed' },
                { name: 'LG', accountManager: 'Ahmed Saleem' },
                { name: 'Lipsy', accountManager: 'Ahmed Saleem' },
                { name: 'Makan', accountManager: 'Ahmed Saleem' },
                { name: 'Noon RTV', accountManager: 'Ibrahim Fadaly' },
                { name: 'Rasees', accountManager: 'Abdullah Ahmed' },
                { name: 'Red Cactus/Asteri', accountManager: 'Ahmed Saleem' },
                { name: 'SACO', accountManager: 'Ibrahim Fadaly' },
                { name: 'Shiaka Store', accountManager: 'Abdullah Ahmed' },
                { name: 'SL Global', accountManager: 'Ahmed Saleem' },
                { name: 'Squat Wolf', accountManager: 'Abdullah Ahmed' },
                { name: 'TLC', accountManager: 'Ahmed Saleem' },
                { name: 'Torod', accountManager: 'Ibrahim Fadaly' },
                { name: 'Al Dakhel Oud', accountManager: 'Abdullah Ahmed' },
                { name: 'Al Esayi Electronics', accountManager: 'Abdullah Ahmed' },
                { name: 'Trendyol', accountManager: 'Ibrahim Fadaly' },
                { name: 'Her KSA', accountManager: 'Ibrahim Fadaly' },
                { name: 'Blue Arch', accountManager: 'Abdullah Ahmed' },
                { name: 'Tahour Store', accountManager: 'Abdullah Ahmed' },
                { name: 'Sandouq Albadaee', accountManager: 'Ibrahim Fadaly' },
                { name: 'Reefi', accountManager: 'Abdullah Ahmed' },
                { name: 'Eyen Optics', accountManager: 'Abdullah Ahmed' },
                { name: 'Afaq Al Hasoob', accountManager: 'Abdullah Ahmed' },
                { name: 'Oud Almaazim', accountManager: 'Abdullah Ahmed' },
                { name: 'Alsaad home', accountManager: 'Abdullah Ahmed' },
                { name: 'Fast Track', accountManager: 'Abdullah Ahmed' },
                { name: 'Packman', accountManager: 'Ahmed Saleem' }
            ];

            const serviceTypes = ['Last Mile Only', 'Fulfillment Only', 'Last Mile & Fulfillment'];
            const languages = ['Arabic', 'English'];

            return q3PendingCustomers.map((customer, index) => ({
                id: 70 + index, // Start from 70 since we have 69 existing surveys
                companyName: customer.name,
                serviceType: serviceTypes[Math.floor(Math.random() * serviceTypes.length)],
                overallSatisfaction: null, // Pending - no rating yet
                npsScore: null,
                lastMileSatisfaction: null,
                reverseDeliverySatisfaction: null,
                fulfillmentSatisfaction: null,
                accountManager: customer.accountManager,
                communicationClarity: null,
                responsiveness: null,
                problemResolution: null,
                customizationAbility: null,
                systemsSatisfaction: null,
                itSupportSatisfaction: null,
                suggestions: '',
                submittedAt: null, // Pending - no submission date
                isCompleted: false,
                language: languages[Math.floor(Math.random() * languages.length)],
                quarter: 'Q3' // Add quarter identifier
            }));
        }

        // Function to determine quarter based on submission date
        function getQuarterFromDate(date) {
            if (!date) return 'Q3'; // Pending surveys are Q3

            const year = date.getFullYear();
            const month = date.getMonth() + 1; // getMonth() returns 0-11

            // Based on your business quarters:
            // Q1: Jan-Mar (1-3)
            // Q2: Apr-Jul (4-7) - extends through July
            // Q3: Aug-Oct (8-10) - upcoming period for pending customers
            // Q4: Nov-Dec (11-12)

            if (month >= 1 && month <= 3) return 'Q1';
            if (month >= 4 && month <= 7) return 'Q2'; // Extended to include July
            if (month >= 8 && month <= 10) return 'Q3'; // August-October
            if (month >= 11 && month <= 12) return 'Q4';

            return 'Q1'; // Default fallback
        }

        // Function to filter surveys by quarter
        function filterSurveysByQuarter(surveys, quarter) {
            if (quarter === 'All Quarters') {
                return surveys;
            }

            return surveys.filter(survey => {
                const surveyQuarter = getQuarterFromDate(survey.submittedAt);
                return surveyQuarter === quarter;
            });
        }

        // Generate mock data for testing and demonstration
        function generateMockSurveyData() {
            const companies = [
                ' ', '  ', ' ', ' ', ' ',
                'Acme Corp', 'TechStart Inc', 'Global Solutions', 'Innovation Labs', 'Future Systems',
                'Digital Dynamics', 'Smart Logistics', 'Prime Delivery', 'Express Solutions', 'Rapid Transit'
            ];

            const accountManagers = ['Abdullah Ahmed', 'Ibrahim Fadaly', 'Ahmed Saleem'];
            const serviceTypes = ['Last Mile Only', 'Fulfillment Only', 'Last Mile & Fulfillment'];
            const languages = ['Arabic', 'English'];

            const mockData = [];

            for (let i = 0; i < 25; i++) {
                // Ensure we have a good mix of completed and pending surveys
                const isCompleted = i < 18; // First 18 are completed (72% completion rate)
                const submittedAt = isCompleted ? new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000) : null;
                const language = languages[Math.floor(Math.random() * languages.length)];

                mockData.push({
                    id: i + 1,
                    companyName: companies[Math.floor(Math.random() * companies.length)],
                    serviceType: serviceTypes[Math.floor(Math.random() * serviceTypes.length)],
                    overallSatisfaction: isCompleted ? (Math.random() > 0.3 ? Math.floor(Math.random() * 2) + 4 : Math.floor(Math.random() * 3) + 1) : null, // 70% satisfied (4-5 rating)
                    npsScore: isCompleted ? Math.floor(Math.random() * 10) + 1 : null,
                    lastMileSatisfaction: isCompleted ? Math.floor(Math.random() * 5) + 1 : null,
                    reverseDeliverySatisfaction: isCompleted ? Math.floor(Math.random() * 5) + 1 : null,
                    fulfillmentSatisfaction: isCompleted ? Math.floor(Math.random() * 5) + 1 : null,
                    accountManager: accountManagers[Math.floor(Math.random() * accountManagers.length)],
                    communicationClarity: isCompleted ? Math.floor(Math.random() * 5) + 1 : null,
                    responsiveness: isCompleted ? Math.floor(Math.random() * 5) + 1 : null,
                    problemResolution: isCompleted ? Math.floor(Math.random() * 5) + 1 : null,
                    customizationAbility: isCompleted ? Math.floor(Math.random() * 5) + 1 : null,
                    systemsSatisfaction: isCompleted ? Math.floor(Math.random() * 5) + 1 : null,
                    itSupportSatisfaction: isCompleted ? Math.floor(Math.random() * 5) + 1 : null,
                    suggestions: isCompleted ? (language === 'Arabic' ? '  ' : 'Sample feedback text for testing purposes.') : '',
                    submittedAt: submittedAt,
                    isCompleted: isCompleted,
                    language: language
                });
            }

            return mockData;
        }

        // Listen for data refresh events
        document.addEventListener('dataRefreshed', function (event) {
            console.log('Data refreshed at:', new Date(event.detail.timestamp));
            console.log('Event detail:', event.detail);
            // Here you would update the UI components with new data
            // This will be implemented in future tasks
        });

        // Function to print Google Sheets data for debugging
        window.printGoogleSheetsData = async function () {
            try {
                console.log('=== GOOGLE SHEETS DATA ANALYSIS ===');
                const data = await window.DashboardAPI.getData(true); // Force refresh
                console.log('Total records from Google Sheets:', data.length);

                if (data.length > 0) {
                    console.log('Sample record structure:', data[0]);

                    // Analyze completion status
                    const completedSurveys = data.filter(survey => survey.submittedAt);
                    const pendingSurveys = data.filter(survey => !survey.submittedAt);

                    console.log('Completed surveys:', completedSurveys.length);
                    console.log('Pending surveys:', pendingSurveys.length);
                    console.log('Completion rate:', Math.round((completedSurveys.length / data.length) * 100) + '%');

                    // Analyze satisfaction
                    const satisfiedCustomers = data.filter(survey =>
                        survey.submittedAt && survey.overallSatisfaction >= 4
                    );
                    console.log('Satisfied customers (4-5 rating):', satisfiedCustomers.length);
                    console.log('Satisfaction rate:', Math.round((satisfiedCustomers.length / completedSurveys.length) * 100) + '%');

                    // Print first few records
                    console.log('First 5 records:');
                    data.slice(0, 5).forEach((record, index) => {
                        console.log(`Record ${index + 1}:`, {
                            company: record.companyName,
                            submittedAt: record.submittedAt,
                            satisfaction: record.overallSatisfaction,
                            accountManager: record.accountManager
                        });
                    });
                } else {
                    console.log('No data received from Google Sheets');
                }
                console.log('=== END ANALYSIS ===');
            } catch (error) {
                console.error('Error fetching Google Sheets data:', error);
            }
        };

        // Test function to manually update the dashboard
        window.testUpdateDashboard = function () {
            console.log('Manual test update triggered');
            const mockData = generateMockSurveyData();
            console.log('Generated test data:', mockData.length, 'records');

            // Calculate metrics directly
            const totalSurveys = mockData.length;
            const completedSurveys = mockData.filter(survey => !!survey.submittedAt).length;
            const completionPercentage = Math.round((completedSurveys / totalSurveys) * 100);
            const satisfiedCustomers = mockData.filter(survey => survey.submittedAt && survey.overallSatisfaction >= 4).length;
            const satisfactionPercentage = Math.round((satisfiedCustomers / completedSurveys) * 100);

            console.log('Direct calculation:', {
                totalSurveys,
                completedSurveys,
                completionPercentage,
                satisfiedCustomers,
                satisfactionPercentage
            });

            // Update UI directly
            const totalElement = document.getElementById('total-surveys-value');
            const completionElement = document.getElementById('completion-rate-value');
            const satisfactionElement = document.getElementById('satisfaction-rate-value');

            if (totalElement) totalElement.textContent = totalSurveys;
            if (completionElement) completionElement.textContent = completionPercentage + '%';
            if (satisfactionElement) satisfactionElement.textContent = satisfactionPercentage + '%';

            console.log('UI elements updated directly');

            if (window.csatSummaryManager) {
                console.log('Also calling updateSummaryMetrics');
                window.csatSummaryManager.updateSummaryMetrics(mockData);
            } else {
                console.log('CSAT Summary Manager not available');
            }
        };

        // ===================================================================
        // CSAT Summary Page Implementation
        // ===================================================================

        /**
         * CSAT Summary Page Manager
         * Handles data loading, metric calculations, and UI updates for the CSAT Summary page
         * Requirements: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7
         */
        class CSATSummaryManager {
            constructor() {
                this.isInitialized = false;
                this.currentData = null;
                this.animationDuration = 1500; // 1.5 seconds for counting animation

                // Bind methods
                this.handleDataRefresh = this.handleDataRefresh.bind(this);

                // Listen for data refresh events
                document.addEventListener('dataRefreshed', this.handleDataRefresh);
            }

            /**
             * Initialize the CSAT Summary page
             * Requirements: 3.7
             */
            async init() {
                if (this.isInitialized) return;

                try {
                    // Show loading state
                    this.showLoadingState();

                    // Load initial data
                    const data = await window.DashboardAPI.getData();
                    await this.updateSummaryMetrics(data);

                    this.isInitialized = true;
                } catch (error) {
                    console.error('Failed to initialize CSAT Summary:', error);
                    this.showErrorState();
                } finally {
                    this.hideLoadingState();
                }
            }

            /**
             * Handle data refresh events
             * Requirements: 2.4
             */
            async handleDataRefresh(event) {
                if (event.detail && event.detail.data) {
                    await this.updateSummaryMetrics(event.detail.data);
                }
            }

            /**
             * Show skeleton loading state
             * Requirements: 3.7
             */
            showLoadingState() {
                const loadingElement = document.getElementById('csat-loading');
                const metricsElement = document.getElementById('csat-metrics');
                const productLoadingElement = document.getElementById('product-breakdown-loading');
                const productElement = document.getElementById('product-breakdown');

                // Disable skeleton placeholders during initial load
                if (loadingElement && metricsElement) {
                    loadingElement.style.display = 'none';
                    metricsElement.style.display = 'grid';
                }

                if (productLoadingElement && productElement) {
                    productLoadingElement.style.display = 'none';
                    productElement.style.display = 'grid';
                }
            }

            /**
             * Hide skeleton loading state
             * Requirements: 3.7
             */
            hideLoadingState() {
                const loadingElement = document.getElementById('csat-loading');
                const metricsElement = document.getElementById('csat-metrics');
                const productLoadingElement = document.getElementById('product-breakdown-loading');
                const productElement = document.getElementById('product-breakdown');

                if (loadingElement && metricsElement) {
                    loadingElement.style.display = 'none';
                    metricsElement.style.display = 'grid';
                }

                if (productLoadingElement && productElement) {
                    productLoadingElement.style.display = 'none';
                    productElement.style.display = 'grid';
                }
            }

            /**
             * Show error state when data loading fails
             */
            showErrorState(error = null) {
                // Show error in metrics container
                const metricsContainer = document.getElementById('csat-metrics');
                const productContainer = document.getElementById('product-breakdown');

                if (metricsContainer) {
                    uiErrorHandler.showComponentError(metricsContainer, error, () => this.refresh());
                }

                if (productContainer) {
                    uiErrorHandler.showComponentError(productContainer, error, () => this.refresh());
                }
            }

            /**
             * Show empty state when no data is available
             */
            showEmptyState() {
                const metricsContainer = document.getElementById('csat-metrics');
                const productContainer = document.getElementById('product-breakdown');

                if (metricsContainer) {
                    uiErrorHandler.createEmptyState(metricsContainer, 'noData');
                }

                if (productContainer) {
                    uiErrorHandler.createEmptyState(productContainer, 'noData');
                }
            }

            /**
             * Update all summary metrics with new data
             * Requirements: 3.1, 3.2, 3.3
             */
            async updateSummaryMetrics(surveyData) {
                if (!surveyData || !Array.isArray(surveyData)) {
                    console.warn('Invalid survey data provided to CSAT Summary');
                    this.showEmptyState();
                    return;
                }

                if (surveyData.length === 0) {
                    // For quarter filters with no records, show cards with zeros
                    const zeroMetrics = {
                        totalSurveys: 0,
                        completionPercentage: 0,
                        satisfiedCustomersPercentage: 0
                    };

                    const zeroBreakdown = {
                        'Last Mile Only': { completed: 0, completionRate: 0, satisfactionRate: 0 },
                        'Fulfillment Only': { completed: 0, completionRate: 0, satisfactionRate: 0 },
                        'Last Mile & Fulfillment': { completed: 0, completionRate: 0, satisfactionRate: 0 }
                    };

                    await this.updateMainMetrics(zeroMetrics);
                    await this.updateProductTypeBreakdown(zeroBreakdown);
                    return;
                }

                this.currentData = surveyData;

                try {
                    // Validate data quality
                    const validation = window.DashboardAPI.validateDataQuality(surveyData);

                    // Skip partial data warnings for Q3 pending customers (they're supposed to be incomplete)
                    // if (validation.hasIssues && validation.warnings.length > 0) {
                    //     const metricsContainer = document.getElementById('csat-summary-panel');
                    //     if (metricsContainer) {
                    //         uiErrorHandler.handlePartialData(metricsContainer, surveyData, validation.warnings);
                    //     }
                    // }

                    // Calculate overall metrics using the data processor
                    const processor = new SurveyDataProcessor();
                    const overallMetrics = processor.calculateOverallMetrics(surveyData);
                    const productBreakdown = processor.calculateProductTypeBreakdown(surveyData);

                    // Debug: Log calculated metrics
                    console.log('Calculated overall metrics:', overallMetrics);
                    console.log('Product breakdown:', productBreakdown);

                    // Update main metrics with animations
                    await this.updateMainMetrics(overallMetrics);

                    // Update product type breakdown
                    await this.updateProductTypeBreakdown(productBreakdown);

                } catch (error) {
                    console.error('Error updating CSAT summary metrics:', error);
                    this.showErrorState(error);
                }
            }

            /**
             * Update main metrics cards with counting animations
             * Requirements: 3.1, 3.2, 3.6
             */
            async updateMainMetrics(metrics) {
                console.log('updateMainMetrics called with:', metrics);

                // Animate total surveys
                this.animateValue('total-surveys-value', 0, metrics.totalSurveys);

                // Animate completion rate with color coding
                const completionElement = document.getElementById('completion-rate-value');
                console.log('Updating completion rate to:', metrics.completionPercentage + '%');
                this.animateValue('completion-rate-value', 0, metrics.completionPercentage, '%');
                this.updateProgressBar('completion-rate-progress', metrics.completionPercentage);

                // Apply color coding for completion rate (Requirements: 3.4, 3.5)
                if (metrics.completionPercentage >= 80) {
                    completionElement.className = 'metric-value success';
                } else if (metrics.completionPercentage >= 60) {
                    completionElement.className = 'metric-value warning';
                } else {
                    completionElement.className = 'metric-value';
                }

                // Animate satisfaction rate with color coding
                const satisfactionElement = document.getElementById('satisfaction-rate-value');
                this.animateValue('satisfaction-rate-value', 0, metrics.satisfiedCustomersPercentage, '%');
                this.updateProgressBar('satisfaction-rate-progress', metrics.satisfiedCustomersPercentage);

                // Apply color coding for satisfaction rate (Requirements: 3.4, 3.5)
                if (metrics.satisfiedCustomersPercentage >= 80) {
                    satisfactionElement.className = 'metric-value success';
                } else if (metrics.satisfiedCustomersPercentage >= 60) {
                    satisfactionElement.className = 'metric-value warning';
                } else {
                    satisfactionElement.className = 'metric-value';
                }
            }

            /**
             * Update product type breakdown cards
             * Requirements: 3.3
             */
            async updateProductTypeBreakdown(breakdown) {
                // Last Mile Only
                this.animateValue('lastmile-surveys-value', 0, breakdown['Last Mile Only'].completed);
                this.updateText('lastmile-completion-rate', breakdown['Last Mile Only'].completionRate + '%');
                this.updateText('lastmile-satisfaction-rate', breakdown['Last Mile Only'].satisfactionRate + '%');
                this.updateProgressBar('lastmile-completion-progress', breakdown['Last Mile Only'].completionRate);
                this.updateProgressBar('lastmile-satisfaction-progress', breakdown['Last Mile Only'].satisfactionRate);

                // Fulfillment Only
                this.animateValue('fulfillment-surveys-value', 0, breakdown['Fulfillment Only'].completed);
                this.updateText('fulfillment-completion-rate', breakdown['Fulfillment Only'].completionRate + '%');
                this.updateText('fulfillment-satisfaction-rate', breakdown['Fulfillment Only'].satisfactionRate + '%');
                this.updateProgressBar('fulfillment-completion-progress', breakdown['Fulfillment Only'].completionRate);
                this.updateProgressBar('fulfillment-satisfaction-progress', breakdown['Fulfillment Only'].satisfactionRate);

                // Last Mile & Fulfillment
                this.animateValue('combined-surveys-value', 0, breakdown['Last Mile & Fulfillment'].completed);
                this.updateText('combined-completion-rate', breakdown['Last Mile & Fulfillment'].completionRate + '%');
                this.updateText('combined-satisfaction-rate', breakdown['Last Mile & Fulfillment'].satisfactionRate + '%');
                this.updateProgressBar('combined-completion-progress', breakdown['Last Mile & Fulfillment'].completionRate);
                this.updateProgressBar('combined-satisfaction-progress', breakdown['Last Mile & Fulfillment'].satisfactionRate);

                // Apply color coding to progress bars based on performance
                this.applyProgressBarColorCoding();
            }

            /**
             * Apply color coding to progress bars based on performance levels
             * Requirements: 3.4, 3.5
             */
            applyProgressBarColorCoding() {
                const progressBars = [
                    'lastmile-completion-progress', 'lastmile-satisfaction-progress',
                    'fulfillment-completion-progress', 'fulfillment-satisfaction-progress',
                    'combined-completion-progress', 'combined-satisfaction-progress'
                ];

                progressBars.forEach(barId => {
                    const bar = document.getElementById(barId);
                    if (bar) {
                        const width = parseInt(bar.style.width);

                        // Remove existing color classes
                        bar.classList.remove('success', 'warning', 'error');

                        // Apply color based on performance
                        if (width >= 80) {
                            bar.classList.add('success');
                        } else if (width >= 60) {
                            bar.classList.add('warning');
                        } else if (width > 0) {
                            // Keep default primary color for low but non-zero values
                        }
                    }
                });
            }

            /**
             * Animate counting from start to end value with performance optimizations
             * Requirements: 3.6
             */
            animateValue(elementId, start, end, suffix = '') {
                console.log('animateValue called:', elementId, 'from', start, 'to', end, 'suffix:', suffix);
                const element = document.getElementById(elementId);
                if (!element) {
                    console.log('Element not found:', elementId);
                    return;
                }

                // Check for reduced motion preference
                if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    element.textContent = Math.round(end) + suffix;
                    return;
                }

                // Add animation class
                element.classList.add('animate');

                // Use requestAnimationFrame for better performance
                const startTime = performance.now();
                const duration = this.animationDuration;

                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Easing function for smooth animation
                    const easeOutQuart = 1 - Math.pow(1 - progress, 4);
                    const current = start + (end - start) * easeOutQuart;

                    element.textContent = Math.round(current) + suffix;

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        element.classList.remove('animate');

                        // Announce completion to screen readers
                        if (window.accessibilityManager) {
                            const label = element.closest('.metric-card')?.querySelector('.metric-card-title')?.textContent;
                            if (label) {
                                window.accessibilityManager.announce(`${label}: ${Math.round(end)}${suffix}`);
                            }
                        }
                    }
                };

                requestAnimationFrame(animate);
            }

            /**
             * Update progress bar width with animation and performance optimizations
             */
            updateProgressBar(elementId, percentage) {
                const element = document.getElementById(elementId);
                if (!element) return;

                // Check for reduced motion preference
                if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    element.style.width = percentage + '%';
                    return;
                }

                // Use requestAnimationFrame for smooth animation
                requestAnimationFrame(() => {
                    element.style.width = percentage + '%';

                    // Add ARIA attributes for screen readers
                    element.setAttribute('aria-valuenow', percentage);
                    element.setAttribute('aria-valuemin', '0');
                    element.setAttribute('aria-valuemax', '100');
                    element.setAttribute('role', 'progressbar');
                    element.setAttribute('aria-label', `Progress: ${percentage}%`);
                });
            }

            /**
             * Update text content without animation
             */
            updateText(elementId, text) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = text;
                }
            }

            /**
             * Reset product breakdown to zero values
             */
            resetProductBreakdown() {
                const serviceTypes = ['lastmile', 'fulfillment', 'combined'];

                serviceTypes.forEach(type => {
                    this.animateValue(`${type}-surveys-value`, 0, 0);
                    this.updateText(`${type}-completion-rate`, '0%');
                    this.updateText(`${type}-satisfaction-rate`, '0%');
                    this.updateProgressBar(`${type}-completion-progress`, 0);
                    this.updateProgressBar(`${type}-satisfaction-progress`, 0);
                });
            }

            /**
             * Refresh data manually
             */
            async refresh() {
                try {
                    this.showLoadingState();
                    const data = await window.DashboardAPI.getData(true);
                    await this.updateSummaryMetrics(data);
                } catch (error) {
                    console.error('Failed to refresh CSAT Summary:', error);
                    this.showErrorState();
                } finally {
                    this.hideLoadingState();
                }
            }
        }

        // Initialize CSAT Summary Manager
        let csatSummaryManager;

        // Initialize CSAT Summary when DOM is ready
        document.addEventListener('DOMContentLoaded', function () {
            console.log('Initializing CSAT Summary Manager...');
            csatSummaryManager = new CSATSummaryManager();
            window.csatSummaryManager = csatSummaryManager; // Ensure it's available globally
            console.log('CSAT Summary Manager created:', !!csatSummaryManager);

            // Initialize the manager
            csatSummaryManager.init();

            // Initialize immediately if CSAT Summary tab is active
            const csatPanel = document.getElementById('csat-summary-panel');
            if (csatPanel && csatPanel.classList.contains('active')) {
                csatSummaryManager.init();
            }
        });

        // Initialize CSAT Summary when tab becomes active
        document.addEventListener('click', function (event) {
            if (event.target.matches('[data-tab="csat-summary"]')) {
                if (csatSummaryManager && !csatSummaryManager.isInitialized) {
                    csatSummaryManager.init();
                }
            }
        });

        // Expose CSAT Summary manager for debugging
        window.CSATSummaryManager = CSATSummaryManager;
        // window.csatSummaryManager will be set in DOMContentLoaded

        // ===================================================================
        // Customer Status Page Implementation
        // ===================================================================

        /**
         * Customer Status Page Manager
         * Handles data loading and UI updates for the Customer Status page
         * Requirements: 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7
         */
        class CustomerStatusManager {
            constructor() {
                this.isInitialized = false;
                this.currentData = null;

                // Bind methods
                this.handleDataRefresh = this.handleDataRefresh.bind(this);
                this.handleCustomerClick = this.handleCustomerClick.bind(this);

                // Listen for data refresh events
                document.addEventListener('dataRefreshed', this.handleDataRefresh);
            }

            /**
             * Initialize the Customer Status page
             * Requirements: 4.1, 4.2
             */
            async init() {
                if (this.isInitialized) return;

                try {
                    // Show loading state
                    this.showLoadingState();

                    // Load initial data
                    const data = await window.DashboardAPI.getData();
                    await this.updateCustomerStatus(data);

                    // Set up event listeners
                    this.setupEventListeners();

                    this.isInitialized = true;
                } catch (error) {
                    console.error('Failed to initialize Customer Status:', error);
                    this.showErrorState();
                } finally {
                    this.hideLoadingState();
                }
            }

            /**
             * Handle data refresh events
             * Requirements: 2.4
             */
            async handleDataRefresh(event) {
                if (event.detail && event.detail.data) {
                    await this.updateCustomerStatus(event.detail.data);
                }
            }

            /**
             * Show loading state for tables
             */
            showLoadingState() {
                const completedTableBody = document.querySelector('#completed-surveys-table tbody');
                const pendingTableBody = document.querySelector('#pending-surveys-table tbody');
                const accordionContainer = document.querySelector('#completed-surveys-accordion');

                if (completedTableBody) {
                    completedTableBody.innerHTML = this.generateSkeletonRows(3);
                }

                if (pendingTableBody) {
                    pendingTableBody.innerHTML = this.generateSkeletonRows(3);
                }

                if (accordionContainer) {
                    accordionContainer.innerHTML = this.generateSkeletonAccordion(3);
                }
            }

            /**
             * Hide loading state
             */
            hideLoadingState() {
                // Loading state is hidden when real data is populated
            }

            /**
             * Show error state when data loading fails
             */
            showErrorState(error = null) {
                const completedTableBody = document.querySelector('#completed-surveys-table tbody');
                const pendingTableBody = document.querySelector('#pending-surveys-table tbody');
                const accordionContainer = document.querySelector('#completed-surveys-accordion');

                if (completedTableBody) {
                    uiErrorHandler.handleTableEmptyState(completedTableBody, 'loadingError', 4);
                }

                if (pendingTableBody) {
                    uiErrorHandler.handleTableEmptyState(pendingTableBody, 'loadingError', 3);
                }

                if (accordionContainer) {
                    uiErrorHandler.showComponentError(accordionContainer, error, () => this.refresh());
                }
            }

            /**
             * Show empty states for different scenarios
             */
            showEmptyStates(completedSurveys, pendingSurveys) {
                const completedTableBody = document.querySelector('#completed-surveys-table tbody');
                const pendingTableBody = document.querySelector('#pending-surveys-table tbody');
                const accordionContainer = document.querySelector('#completed-surveys-accordion');

                if (completedSurveys.length === 0 && completedTableBody) {
                    uiErrorHandler.handleTableEmptyState(completedTableBody, 'noCompletedSurveys', 4);
                }

                if (pendingSurveys.length === 0 && pendingTableBody) {
                    uiErrorHandler.handleTableEmptyState(pendingTableBody, 'noPendingSurveys', 3);
                }

                if (completedSurveys.length === 0 && accordionContainer) {
                    uiErrorHandler.createEmptyState(accordionContainer, 'noCompletedSurveys');
                }
            }

            /**
             * Generate skeleton loading rows
             */
            generateSkeletonRows(count) {
                let rows = '';
                for (let i = 0; i < count; i++) {
                    rows += `
                        <tr>
                            <td><div class="skeleton skeleton-text"></div></td>
                            <td><div class="skeleton skeleton-text"></div></td>
                            <td><div class="skeleton skeleton-text"></div></td>
                            <td><div class="skeleton skeleton-text"></div></td>
                        </tr>
                    `;
                }
                return rows;
            }

            /**
             * Generate skeleton loading accordion cards
             * Requirements: 5.1, 5.6
             */
            generateSkeletonAccordion(count) {
                let cards = '';
                for (let i = 0; i < count; i++) {
                    cards += `
                        <div class="accordion-card">
                            <div class="accordion-header" style="cursor: default;">
                                <div class="accordion-header-content">
                                    <div class="skeleton skeleton-text title"></div>
                                    <div class="accordion-meta">
                                        <div class="skeleton skeleton-text small" style="width: 120px;"></div>
                                        <div class="skeleton skeleton-text small" style="width: 80px;"></div>
                                    </div>
                                </div>
                                <div class="skeleton" style="width: 20px; height: 20px;"></div>
                            </div>
                        </div>
                    `;
                }
                return cards;
            }

            /**
             * Update customer status tables with new data
             * Requirements: 4.1, 4.2, 4.3
             */
            async updateCustomerStatus(surveyData) {
                if (!surveyData || !Array.isArray(surveyData)) {
                    console.warn('Invalid survey data provided to Customer Status');
                    this.showErrorState();
                    return;
                }

                if (surveyData.length === 0) {
                    this.showEmptyStates([], []);
                    return;
                }

                this.currentData = surveyData;

                try {
                    // Validate data quality
                    const validation = window.DashboardAPI.validateDataQuality(surveyData);

                    // Skip partial data warnings for Q3 pending customers (they're supposed to be incomplete)
                    // if (validation.hasIssues && validation.warnings.length > 0) {
                    //     const statusContainer = document.getElementById('customer-status-panel');
                    //     if (statusContainer) {
                    //         uiErrorHandler.handlePartialData(statusContainer, surveyData, validation.warnings);
                    //     }
                    // }

                    // Separate completed and pending surveys
                    const completedSurveys = surveyData.filter(survey => survey.submittedAt);
                    const pendingSurveys = surveyData.filter(survey => !survey.submittedAt);

                    // Sort completed surveys by completion date (most recent first)
                    // Requirements: 4.6
                    completedSurveys.sort((a, b) => {
                        const dateA = new Date(a.submittedAt);
                        const dateB = new Date(b.submittedAt);
                        return dateB - dateA; // Descending order (most recent first)
                    });

                    // Sort pending surveys alphabetically by customer name
                    // Requirements: 4.7
                    pendingSurveys.sort((a, b) => {
                        return a.companyName.localeCompare(b.companyName);
                    });

                    // Check for empty states
                    if (completedSurveys.length === 0 && pendingSurveys.length === 0) {
                        this.showEmptyStates([], []);
                        return;
                    }

                    // Update tables
                    this.updateCompletedSurveysTable(completedSurveys);
                    this.updatePendingSurveysTable(pendingSurveys);

                    // Update completed surveys accordion
                    this.updateCompletedSurveysAccordion(completedSurveys);

                    // Show empty states for individual sections if needed
                    this.showEmptyStates(completedSurveys, pendingSurveys);

                } catch (error) {
                    console.error('Error updating customer status:', error);
                    this.showErrorState(error);
                }
            }

            /**
             * Refresh data manually
             */
            async refresh() {
                try {
                    this.showLoadingState();
                    const data = await window.DashboardAPI.getData(true);
                    await this.updateCustomerStatus(data);
                } catch (error) {
                    console.error('Failed to refresh Customer Status:', error);
                    this.showErrorState(error);
                } finally {
                    this.hideLoadingState();
                }
            }

            /**
             * Update completed surveys table
             * Requirements: 4.2, 4.4, 4.5, 4.6
             */
            updateCompletedSurveysTable(completedSurveys) {
                const tableBody = document.querySelector('#completed-surveys-table tbody');
                if (!tableBody) return;

                if (completedSurveys.length === 0) {
                    tableBody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: var(--spacing-xl); color: #666;">No completed surveys found</td></tr>';
                    return;
                }

                const rows = completedSurveys.map((survey, index) => {
                    const completionDate = this.formatDate(survey.submittedAt);

                    return `
                        <tr role="row">
                            <td role="gridcell">
                                <a href="#" 
                                   class="table-cell-link" 
                                   data-customer-id="${survey.id}" 
                                   data-customer-name="${this.escapeHtml(survey.companyName)}"
                                   aria-describedby="completed-survey-${survey.id}-description">
                                    ${this.escapeHtml(survey.companyName)}
                                </a>
                                <span id="completed-survey-${survey.id}-description" class="sr-only">
                                    Click to view detailed survey responses for ${this.escapeHtml(survey.companyName)}
                                </span>
                            </td>
                            <td role="gridcell">${this.escapeHtml(survey.accountManager || 'Not Assigned')}</td>
                            <td role="gridcell">
                                <time datetime="${survey.submittedAt ? survey.submittedAt.toISOString() : ''}">${completionDate}</time>
                            </td>
                            <td role="gridcell">
                                <span class="table-status-badge completed" aria-label="Survey status: Completed">Completed</span>
                            </td>
                        </tr>
                    `;
                }).join('');

                tableBody.innerHTML = rows;
            }

            /**
             * Update pending surveys table
             * Requirements: 4.3, 4.4, 4.7
             */
            updatePendingSurveysTable(pendingSurveys) {
                const tableBody = document.querySelector('#pending-surveys-table tbody');
                if (!tableBody) return;

                if (pendingSurveys.length === 0) {
                    tableBody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: var(--spacing-xl); color: #666;">No pending surveys found</td></tr>';
                    return;
                }

                const rows = pendingSurveys.map((survey, index) => {
                    return `
                        <tr role="row">
                            <td role="gridcell">
                                <a href="#" 
                                   class="table-cell-link" 
                                   data-customer-id="${survey.id}" 
                                   data-customer-name="${this.escapeHtml(survey.companyName)}"
                                   aria-describedby="pending-survey-${survey.id}-description">
                                    ${this.escapeHtml(survey.companyName)}
                                </a>
                                <span id="pending-survey-${survey.id}-description" class="sr-only">
                                    Customer with pending survey. Click to view details.
                                </span>
                            </td>
                            <td role="gridcell">${this.escapeHtml(survey.accountManager || 'Not Assigned')}</td>
                            <td role="gridcell">
                                <span class="table-status-badge pending" aria-label="Survey status: Pending">Pending</span>
                            </td>
                        </tr>
                    `;
                }).join('');

                tableBody.innerHTML = rows;
            }



            /**
             * Update completed surveys accordion interface
             * Requirements: 5.1, 5.2, 5.3, 5.4, 5.5, 5.6
             */
            updateCompletedSurveysAccordion(completedSurveys) {
                const accordionContainer = document.querySelector('#completed-surveys-accordion');
                if (!accordionContainer) return;

                if (completedSurveys.length === 0) {
                    accordionContainer.innerHTML = '<div style="text-align: center; padding: var(--spacing-xl); color: #666;">No completed surveys found</div>';
                    return;
                }

                // Generate accordion cards for each completed survey
                const accordionCards = completedSurveys.map(survey => {
                    const completionDate = this.formatDate(survey.submittedAt);
                    const ratingClass = this.getSatisfactionRatingClass(survey.overallSatisfaction);
                    const ratingText = this.getSatisfactionRatingText(survey.overallSatisfaction);

                    // Create all survey questions and answers
                    const surveyQuestions = this.generateSurveyQuestions(survey);

                    return `
                        <div class="accordion-card" data-customer-id="${survey.id}">
                            <button class="accordion-header" 
                                    onclick="toggleAccordion(this)"
                                    aria-expanded="false"
                                    aria-controls="accordion-content-${survey.id}"
                                    id="accordion-header-${survey.id}">
                                <div class="accordion-header-content">
                                    <h3 class="accordion-title">${this.escapeHtml(survey.companyName)}</h3>
                                    <div class="accordion-meta">
                                        <span class="accordion-subtitle">Completed: ${completionDate}</span>
                                        <span class="accordion-rating ${ratingClass}" 
                                              aria-label="Overall satisfaction rating: ${survey.overallSatisfaction} out of 5 stars, ${ratingText}">
                                            ${survey.overallSatisfaction}  ${ratingText}
                                        </span>
                                    </div>
                                </div>
                                <svg class="accordion-icon" 
                                     fill="none" 
                                     stroke="currentColor" 
                                     viewBox="0 0 24 24"
                                     aria-hidden="true">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </button>
                            <div class="accordion-content" 
                                 id="accordion-content-${survey.id}"
                                 aria-labelledby="accordion-header-${survey.id}"
                                 role="region">
                                <div class="accordion-body">
                                    ${surveyQuestions}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');

                accordionContainer.innerHTML = accordionCards;

                // Set up highlighting for navigated customers
                this.setupAccordionHighlighting();
            }

            /**
             * Generate survey questions and answers HTML
             * Requirements: 5.3, 5.5
             */
            generateSurveyQuestions(survey) {
                const questions = [
                    { label: 'Overall Satisfaction', value: this.formatRatingAnswer(survey.overallSatisfaction) },
                    { label: 'Service Type', value: survey.serviceType || 'Not specified' },
                    { label: 'NPS Score', value: survey.npsScore ? `${survey.npsScore}/10` : 'Not provided' },
                    { label: 'Last Mile Satisfaction', value: this.formatRatingAnswer(survey.lastMileSatisfaction) },
                    { label: 'Reverse Delivery Satisfaction', value: this.formatRatingAnswer(survey.reverseDeliverySatisfaction) },
                    { label: 'Fulfillment Satisfaction', value: this.formatRatingAnswer(survey.fulfillmentSatisfaction) },
                    { label: 'Account Manager', value: survey.accountManager || 'Not assigned' },
                    { label: 'Communication Clarity', value: this.formatRatingAnswer(survey.communicationClarity) },
                    { label: 'Responsiveness', value: this.formatRatingAnswer(survey.responsiveness) },
                    { label: 'Problem Resolution', value: this.formatRatingAnswer(survey.problemResolution) },
                    { label: 'Customization Ability', value: this.formatRatingAnswer(survey.customizationAbility) },
                    { label: 'Systems Satisfaction', value: this.formatRatingAnswer(survey.systemsSatisfaction) },
                    { label: 'IT Support Satisfaction', value: this.formatRatingAnswer(survey.itSupportSatisfaction) },
                    { label: 'Additional Comments', value: survey.suggestions || 'No additional comments provided' }
                ];

                return questions.map(question => `
                    <div class="survey-question">
                        <div class="survey-question-label">${question.label}</div>
                        <div class="survey-question-answer">${this.escapeHtml(question.value)}</div>
                    </div>
                `).join('');
            }

            /**
             * Get satisfaction rating CSS class based on score
             * Requirements: 5.4
             */
            getSatisfactionRatingClass(rating) {
                if (rating >= 4) return 'excellent';
                if (rating >= 3) return 'good';
                if (rating >= 2) return 'average';
                return 'poor';
            }

            /**
             * Get satisfaction rating text based on score
             * Requirements: 5.4
             */
            getSatisfactionRatingText(rating) {
                if (rating >= 5) return 'Very Satisfied';
                if (rating >= 4) return 'Satisfied';
                if (rating >= 3) return 'Neutral';
                if (rating >= 2) return 'Dissatisfied';
                return 'Very Dissatisfied';
            }

            /**
             * Format rating answer with descriptive text
             * Requirements: 5.3
             */
            formatRatingAnswer(rating) {
                if (!rating || rating === 0) return 'Not provided';

                const ratingTexts = {
                    1: '1 - Very Dissatisfied',
                    2: '2 - Dissatisfied',
                    3: '3 - Neutral',
                    4: '4 - Satisfied',
                    5: '5 - Very Satisfied'
                };

                return ratingTexts[rating] || `${rating}`;
            }

            /**
             * Set up accordion highlighting for customer navigation
             * Requirements: 5.1, 5.2
             */
            setupAccordionHighlighting() {
                // Listen for customer highlight events
                document.addEventListener('highlightCustomerSurvey', (event) => {
                    const { customerId, customerName } = event.detail;
                    this.highlightCustomerAccordion(customerId, customerName);
                });

                // Check if there's a stored highlight request
                const highlightCustomerId = sessionStorage.getItem('highlightCustomerId');
                const highlightCustomerName = sessionStorage.getItem('highlightCustomerName');

                if (highlightCustomerId && highlightCustomerName) {
                    setTimeout(() => {
                        this.highlightCustomerAccordion(highlightCustomerId, highlightCustomerName);
                        // Clear the stored highlight request
                        sessionStorage.removeItem('highlightCustomerId');
                        sessionStorage.removeItem('highlightCustomerName');
                    }, 100);
                }
            }

            /**
             * Highlight and expand specific customer accordion
             * Requirements: 5.1, 5.2
             */
            highlightCustomerAccordion(customerId, customerName) {
                const accordionCard = document.querySelector(`#completed-surveys-accordion .accordion-card[data-customer-id="${customerId}"]`);

                if (accordionCard) {
                    // Expand the accordion
                    const header = accordionCard.querySelector('.accordion-header');
                    if (header && !accordionCard.classList.contains('expanded')) {
                        toggleAccordion(header);
                    }

                    // Scroll to the accordion card
                    accordionCard.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });

                    // Add temporary highlight effect
                    accordionCard.style.boxShadow = '0 0 0 3px var(--primary-main)';
                    accordionCard.style.transition = 'box-shadow 0.3s ease';

                    setTimeout(() => {
                        accordionCard.style.boxShadow = '';
                    }, 2000);
                }
            }

            /**
             * Set up event listeners for customer name clicks
             * Requirements: 4.5
             */
            setupEventListeners() {
                // Use event delegation to handle clicks on customer names
                document.addEventListener('click', this.handleCustomerClick);
            }

            /**
             * Handle customer name clicks to navigate to detailed survey view
             * Requirements: 4.5
             */
            handleCustomerClick(event) {
                const link = event.target.closest('.table-cell-link');
                if (!link) return;

                event.preventDefault();

                const customerId = link.getAttribute('data-customer-id');
                const customerName = link.getAttribute('data-customer-name');

                if (customerId && customerName) {
                    this.navigateToSurveyDetail(customerId, customerName);
                }
            }

            /**
             * Navigate to detailed survey view (Completed Surveys page)
             * Requirements: 4.5
             */
            navigateToSurveyDetail(customerId, customerName) {
                // Switch to the Completed Surveys tab
                const completedSurveysTab = document.querySelector('[data-tab="completed-surveys"]');
                if (completedSurveysTab) {
                    completedSurveysTab.click();

                    // Store the customer ID to highlight the specific survey
                    sessionStorage.setItem('highlightCustomerId', customerId);
                    sessionStorage.setItem('highlightCustomerName', customerName);

                    // Dispatch custom event for the Completed Surveys page to handle highlighting
                    setTimeout(() => {
                        const highlightEvent = new CustomEvent('highlightCustomerSurvey', {
                            detail: { customerId, customerName }
                        });
                        document.dispatchEvent(highlightEvent);
                    }, 300); // Small delay to ensure tab switch completes
                }
            }

            /**
             * Format date for display
             */
            formatDate(dateValue) {
                if (!dateValue) return 'Not Available';

                try {
                    const date = new Date(dateValue);
                    if (isNaN(date.getTime())) return 'Invalid Date';

                    return date.toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric'
                    });
                } catch (error) {
                    return 'Invalid Date';
                }
            }

            /**
             * Escape HTML to prevent XSS
             */
            escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            /**
             * Refresh data manually
             */
            async refresh() {
                try {
                    this.showLoadingState();
                    const data = await window.DashboardAPI.getData(true);
                    await this.updateCustomerStatus(data);
                } catch (error) {
                    console.error('Failed to refresh Customer Status:', error);
                    this.showErrorState();
                } finally {
                    this.hideLoadingState();
                }
            }

            /**
             * Clean up event listeners
             */
            destroy() {
                document.removeEventListener('dataRefreshed', this.handleDataRefresh);
                document.removeEventListener('click', this.handleCustomerClick);
            }
        }

        /**
         * Account Manager Performance Page Manager
         * Handles dynamic display of account manager metrics and performance data
         * Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6
         */
        class AccountManagerPerformanceManager {
            constructor() {
                this.isInitialized = false;
                this.loadingContainer = document.getElementById('account-manager-loading');
                this.cardsContainer = document.getElementById('account-manager-cards');
                this.knownManagers = ['Abdullah Ahmed', 'Ibrahim Fadaly', 'Ahmed Saleem'];
                this.excludedManagers = ['Joanna', 'Amjad Aljowair', 'Starlinks Team']; // Exclude invalid managers from Q3 data
            }

            /**
             * Initialize the Account Manager Performance page
             * Requirements: 6.1
             */
            async init() {
                if (this.isInitialized) return;

                try {
                    this.showLoading();
                    const processedData = await window.DashboardAPI.DataProcessor.processData();
                    this.renderAccountManagerCards(processedData.accountManagerMetrics);
                    this.hideLoading();
                    this.isInitialized = true;
                } catch (error) {
                    console.error('Failed to initialize Account Manager Performance:', error);
                    this.showError('Failed to load account manager data. Please try refreshing the page.');
                    this.hideLoading();
                }
            }

            /**
             * Show loading state
             */
            showLoading() {
                if (this.loadingContainer) {
                    this.loadingContainer.style.display = 'grid';
                }
                if (this.cardsContainer) {
                    this.cardsContainer.style.display = 'none';
                }
            }

            /**
             * Hide loading state
             */
            hideLoading() {
                if (this.loadingContainer) {
                    this.loadingContainer.style.display = 'none';
                }
                if (this.cardsContainer) {
                    this.cardsContainer.style.display = 'grid';
                }
            }

            /**
             * Render account manager performance cards
             * Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6
             */
            renderAccountManagerCards(accountManagerMetrics) {
                if (!this.cardsContainer) return;

                // Get all managers (known + dynamically detected)
                const allManagers = new Set([...this.knownManagers]);
                Object.keys(accountManagerMetrics).forEach(manager => {
                    if (manager && manager.trim()) {
                        allManagers.add(manager);
                    }
                });

                // Sort managers to show known managers first, then alphabetically
                const sortedManagers = Array.from(allManagers)
                    .filter(name => !this.excludedManagers.includes(name))
                    .sort((a, b) => {
                        const aIsKnown = this.knownManagers.includes(a);
                        const bIsKnown = this.knownManagers.includes(b);

                        if (aIsKnown && !bIsKnown) return -1;
                        if (!aIsKnown && bIsKnown) return 1;

                        return a.localeCompare(b);
                    });

                // Generate cards HTML
                const cardsHTML = sortedManagers.map(managerName => {
                    const metrics = accountManagerMetrics[managerName] || {
                        name: managerName,
                        totalAssigned: 0,
                        completed: 0,
                        pending: 0,
                        satisfied: 0,
                        completionRate: 0,
                        satisfactionRate: 0
                    };
                    // Ensure name is present for cards even when metrics object is empty
                    metrics.name = metrics.name || managerName;

                    return this.createManagerCard(metrics);
                }).join('');

                this.cardsContainer.innerHTML = cardsHTML;

                // Animate progress bars after rendering
                setTimeout(() => {
                    this.animateProgressBars();
                }, 100);
            }

            /**
             * Create individual manager performance card
             * Requirements: 6.2, 6.3, 6.4, 6.5, 6.6
             */
            createManagerCard(metrics) {
                const completionRateClass = this.getProgressBarClass(metrics.completionRate);
                const satisfactionRateClass = this.getProgressBarClass(metrics.satisfactionRate);

                return `
                    <div class="metric-card">
                        <div class="metric-card-header">
                            <span class="metric-card-title">${this.escapeHtml(metrics.name)}</span>
                        </div>
                        <div class="metric-value animate" data-target="${metrics.completed}">${metrics.completed}</div>
                        <div class="metric-label">Completed Surveys</div>
                        
                        <div class="progress-container">
                            <div class="progress-label">
                                <span class="progress-label-text">Pending Surveys</span>
                                <span class="progress-label-value">${metrics.pending}</span>
                            </div>
                        </div>
                        
                        <div class="progress-container">
                            <div class="progress-label">
                                <span class="progress-label-text">Completion Rate</span>
                                <span class="progress-label-value">${metrics.completionRate}%</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill ${completionRateClass}" 
                                     data-width="${metrics.completionRate}" 
                                     style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <div class="progress-container">
                            <div class="progress-label">
                                <span class="progress-label-text">Satisfaction Rate</span>
                                <span class="progress-label-value">${metrics.satisfactionRate}%</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill ${satisfactionRateClass}" 
                                     data-width="${metrics.satisfactionRate}" 
                                     style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                `;
            }

            /**
             * Get appropriate CSS class for progress bar based on percentage
             * Requirements: 6.6
             */
            getProgressBarClass(percentage) {
                if (percentage >= 80) return 'success';
                if (percentage >= 60) return '';
                if (percentage >= 40) return 'warning';
                return 'error';
            }

            /**
             * Animate progress bars with CSS-only implementation
             * Requirements: 6.6
             */
            animateProgressBars() {
                const progressBars = this.cardsContainer.querySelectorAll('.progress-fill[data-width]');

                progressBars.forEach((bar, index) => {
                    const targetWidth = bar.getAttribute('data-width');

                    // Stagger animations for visual appeal
                    setTimeout(() => {
                        bar.style.width = `${targetWidth}%`;
                    }, index * 100);
                });

                // Animate metric values with counting effect
                const metricValues = this.cardsContainer.querySelectorAll('.metric-value[data-target]');
                metricValues.forEach((element, index) => {
                    const target = parseInt(element.getAttribute('data-target'));

                    setTimeout(() => {
                        this.animateCounter(element, 0, target, 1000);
                    }, index * 200);
                });
            }

            /**
             * Animate counter from start to end value
             */
            animateCounter(element, start, end, duration) {
                const startTime = performance.now();

                const updateCounter = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Use easing function for smooth animation
                    const easeOutQuart = 1 - Math.pow(1 - progress, 4);
                    const current = Math.round(start + (end - start) * easeOutQuart);

                    element.textContent = current;

                    if (progress < 1) {
                        requestAnimationFrame(updateCounter);
                    }
                };

                requestAnimationFrame(updateCounter);
            }

            /**
             * Show error message
             */
            showError(message) {
                if (this.cardsContainer) {
                    this.cardsContainer.innerHTML = `
                        <div class="metric-card" style="grid-column: 1 / -1; text-align: center; padding: var(--spacing-xl);">
                            <div style="color: var(--error-color); font-size: 1.125rem; margin-bottom: var(--spacing-md);">
                                 Error Loading Data
                            </div>
                            <div style="color: #666; margin-bottom: var(--spacing-lg);">
                                ${this.escapeHtml(message)}
                            </div>
                            <button onclick="accountManagerPerformanceManager.init()" 
                                    style="padding: var(--spacing-sm) var(--spacing-lg); 
                                           background: var(--primary-main); 
                                           color: white; 
                                           border: none; 
                                           border-radius: var(--radius-md); 
                                           cursor: pointer;">
                                Try Again
                            </button>
                        </div>
                    `;
                }
            }

            /**
             * Escape HTML to prevent XSS
             */
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            /**
             * Refresh data and re-render
             */
            async refresh() {
                this.isInitialized = false;
                await this.init();
            }
        }

        // Initialize Account Manager Performance Manager
        let accountManagerPerformanceManager;

        // Initialize Customer Status Manager
        let customerStatusManager;

        // Initialize managers when DOM is ready
        document.addEventListener('DOMContentLoaded', function () {
            console.log('Initializing Account Manager Performance Manager...');
            accountManagerPerformanceManager = new AccountManagerPerformanceManager();
            window.accountManagerPerformanceManager = accountManagerPerformanceManager;
            console.log('Account Manager Performance Manager created:', !!accountManagerPerformanceManager);

            console.log('Initializing Customer Status Manager...');
            customerStatusManager = new CustomerStatusManager();
            window.customerStatusManager = customerStatusManager;
            console.log('Customer Status Manager created:', !!customerStatusManager);
        });

        // Handle tab switching to initialize pages
        document.addEventListener('click', function (event) {
            if (event.target.matches('[data-tab="account-manager-performance"]')) {
                if (accountManagerPerformanceManager && !accountManagerPerformanceManager.isInitialized) {
                    accountManagerPerformanceManager.init();
                }
            }

            if (event.target.matches('[data-tab="customer-status"]')) {
                if (customerStatusManager && !customerStatusManager.isInitialized) {
                    customerStatusManager.init();
                }
            }
        });

        // Listen for data refresh events to update Account Manager Performance
        document.addEventListener('dataRefreshed', function (event) {
            if (accountManagerPerformanceManager && accountManagerPerformanceManager.isInitialized) {
                accountManagerPerformanceManager.refresh();
            }
        });

        // Expose managers for debugging
        window.AccountManagerPerformanceManager = AccountManagerPerformanceManager;
        window.CustomerStatusManager = CustomerStatusManager;
        // Manager instances will be set in DOMContentLoaded

        // Global accordion toggle function
        function toggleAccordion(headerElement) {
            try {
                const card = headerElement.closest('.accordion-card');
                if (!card) return;

                const content = card.querySelector('.accordion-content');
                if (!content) return;

                const isExpanded = card.classList.contains('expanded');

                if (isExpanded) {
                    // Collapse
                    card.classList.remove('expanded');
                    headerElement.setAttribute('aria-expanded', 'false');
                    // Reset inline styles to let CSS handle it
                    content.style.maxHeight = '';
                    content.style.overflow = '';
                    content.style.height = '';
                } else {
                    // Expand
                    card.classList.add('expanded');
                    headerElement.setAttribute('aria-expanded', 'true');

                    // Let CSS handle the expansion with !important rules
                    // Remove any inline styles that might interfere
                    content.style.maxHeight = '';
                    content.style.overflow = '';
                    content.style.height = '';

                    console.log('Accordion expanded - CSS will handle height');
                }
            } catch (error) {
                console.error('Error toggling accordion:', error);
                if (window.errorManager) {
                    window.errorManager.showError('Error expanding survey details', 'error', 3000);
                }
            }
        }

        // Make toggleAccordion globally available
        window.toggleAccordion = toggleAccordion;

        // Quarter Filter Functionality
        class QuarterFilter {
            constructor() {
                this.currentQuarter = 'all';
                this.originalData = null;
                this.init();
            }

            init() {
                console.log('Initializing Quarter Filter...');
                const quarterSelect = document.getElementById('quarter-select');
                if (quarterSelect) {
                    console.log('Quarter select element found, adding event listener');
                    quarterSelect.addEventListener('change', (e) => {
                        console.log('Quarter select changed to:', e.target.value);
                        this.handleQuarterChange(e.target.value);
                    });
                } else {
                    console.error('Quarter select element not found!');
                }

                // Set current year dynamically
                this.updateQuarterOptions();

                // Add test functionality for debugging
                window.testQuarterFilter = () => {
                    console.log('Testing quarter filter...');
                    this.handleQuarterChange('q1');
                };
                console.log('Quarter filter initialized. Use window.testQuarterFilter() to test manually.');
            }

            updateQuarterOptions() {
                const currentYear = new Date().getFullYear();
                const quarterSelect = document.getElementById('quarter-select');
                if (quarterSelect) {
                    const options = quarterSelect.querySelectorAll('option[value^="q"]');
                    options.forEach(option => {
                        const quarter = option.value.toUpperCase();
                        option.textContent = `${quarter} ${currentYear}`;
                        option.value = option.value; // Keep the q1, q2, etc. values
                    });
                }
            }

            handleQuarterChange(quarter) {
                console.log('Quarter filter changed to:', quarter);
                this.currentQuarter = quarter;

                // Save the selected quarter to sessionStorage
                sessionStorage.setItem('selectedQuarter', quarter);

                // Show loading state
                this.showLoadingState();

                // Filter and refresh all dashboard data
                setTimeout(() => {
                    this.filterAndRefreshData();
                }, 100);
            }

            showLoadingState() {
                // Add loading indicator to the filter
                const quarterSelect = document.getElementById('quarter-select');
                if (quarterSelect) {
                    quarterSelect.style.opacity = '0.6';
                    quarterSelect.disabled = true;
                }
            }

            hideLoadingState() {
                const quarterSelect = document.getElementById('quarter-select');
                if (quarterSelect) {
                    quarterSelect.style.opacity = '1';
                    quarterSelect.disabled = false;
                }
            }

            async filterAndRefreshData() {
                try {
                    console.log('=== STARTING QUARTER FILTER REFRESH ===');
                    console.log('Current quarter:', this.currentQuarter);

                    // Sync dropdown with current state
                    const quarterSelect = document.getElementById('quarter-select');
                    if (quarterSelect && quarterSelect.value !== this.currentQuarter) {
                        console.log('Syncing dropdown from', quarterSelect.value, 'to', this.currentQuarter);
                        quarterSelect.value = this.currentQuarter;
                    }

                    // Get original data if not cached
                    if (!this.originalData) {
                        console.log('Fetching original data...');
                        const apiData = await window.DashboardAPI.getData(true);
                        const q3PendingCustomers = generateQ3PendingCustomers();
                        this.originalData = [...apiData, ...q3PendingCustomers];
                        console.log('Combined data prepared:', this.originalData?.length, 'records');
                        console.log('API data:', apiData?.length, 'Q3 pending:', q3PendingCustomers?.length);
                    }

                    if (!this.originalData || this.originalData.length === 0) {
                        console.warn('No original data available for filtering');
                        return;
                    }

                    // Filter data by quarter
                    const filteredData = this.filterDataByQuarter(this.originalData, this.currentQuarter);

                    // Refresh all dashboard sections with filtered data
                    await this.refreshDashboardSections(filteredData);

                    // Update URL or state if needed
                    this.updateState();

                } catch (error) {
                    console.error('Error filtering data by quarter:', error);
                    if (window.errorManager) {
                        window.errorManager.showError('Error filtering data by quarter', 'error', 3000);
                    }
                } finally {
                    this.hideLoadingState();
                }
            }

            filterDataByQuarter(data, quarter) {
                console.log('=== FILTERING DATA BY QUARTER ===');
                console.log('Quarter:', quarter, 'Original data count:', data?.length);

                if (quarter === 'all' || !data) {
                    console.log('Returning all data (no filter applied)');
                    return data;
                }

                const filteredData = data.filter(survey => {
                    // Handle Q3 pending customers (no submittedAt)
                    if (!survey.submittedAt) {
                        const shouldInclude = quarter === 'q3';
                        console.log('Pending customer:', survey.companyName, 'Include in', quarter, '?', shouldInclude);
                        return shouldInclude;
                    }

                    // For completed surveys, filter by submission date
                    const surveyQuarter = getQuarterFromDate(survey.submittedAt);
                    const shouldInclude = surveyQuarter.toLowerCase() === quarter;
                    console.log('Completed survey:', survey.companyName, 'Date:', survey.submittedAt, 'Quarter:', surveyQuarter, 'Include in', quarter, '?', shouldInclude);
                    return shouldInclude;
                });

                console.log('=== FILTER RESULTS ===');
                console.log('Filtered data count:', filteredData.length);
                console.log('Quarter breakdown:', {
                    completed: filteredData.filter(s => s.submittedAt).length,
                    pending: filteredData.filter(s => !s.submittedAt).length
                });
                console.log('Filtered companies:', filteredData.map(s => s.companyName));
                return filteredData;
            }

            async refreshDashboardSections(filteredData) {
                try {
                    console.log('Refreshing dashboard sections with filtered data:', filteredData.length, 'records');

                    // Wait for managers to be available
                    await this.waitForManagers();

                    console.log('Available managers:', {
                        csatSummaryManager: !!window.csatSummaryManager,
                        customerStatusManager: !!window.customerStatusManager,
                        accountManagerPerformanceManager: !!window.accountManagerPerformanceManager
                    });

                    // Refresh CSAT Summary
                    if (window.csatSummaryManager) {
                        console.log('Updating CSAT Summary...');
                        await window.csatSummaryManager.updateSummaryMetrics(filteredData);
                        console.log('CSAT Summary updated');
                    } else {
                        console.warn('CSAT Summary Manager not available');
                    }

                    // Refresh Customer Status
                    if (window.customerStatusManager) {
                        console.log('Updating Customer Status...');
                        await window.customerStatusManager.updateCustomerStatus(filteredData);
                        console.log('Customer Status updated');
                    } else {
                        console.warn('Customer Status Manager not available');
                    }

                    // Refresh Account Manager Performance
                    if (window.accountManagerPerformanceManager) {
                        console.log('Updating Account Manager Performance...');
                        // Process the data first to get account manager metrics
                        const processedData = this.processAccountManagerData(filteredData);
                        window.accountManagerPerformanceManager.renderAccountManagerCards(processedData.accountManagerMetrics);
                        console.log('Account Manager Performance updated');
                    } else {
                        console.warn('Account Manager Performance Manager not available');
                    }

                    // Dispatch custom event for other components
                    document.dispatchEvent(new CustomEvent('quarterFilterChanged', {
                        detail: {
                            quarter: this.currentQuarter,
                            data: filteredData,
                            originalData: this.originalData
                        }
                    }));
                } catch (error) {
                    console.error('Error refreshing dashboard sections:', error);
                }
            }

            // Wait for dashboard managers to be initialized
            async waitForManagers(maxWait = 5000) {
                const startTime = Date.now();

                while (Date.now() - startTime < maxWait) {
                    if (window.csatSummaryManager &&
                        window.customerStatusManager &&
                        window.accountManagerPerformanceManager) {
                        console.log('All managers are now available');
                        return true;
                    }

                    console.log('Waiting for managers to initialize...');
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                console.warn('Timeout waiting for managers to initialize');
                return false;
            }

            // Process account manager data similar to the DataProcessor
            processAccountManagerData(surveyData) {
                const accountManagerMetrics = {};

                // Initialize known managers
                const knownManagers = ['Abdullah Ahmed', 'Ibrahim Fadaly', 'Ahmed Saleem'];
                knownManagers.forEach(manager => {
                    accountManagerMetrics[manager] = {
                        completed: 0,
                        pending: 0,
                        completionRate: 0,
                        satisfactionRate: 0,
                        totalAssigned: 0,
                        satisfiedCustomers: 0
                    };
                });

                // Process survey data
                surveyData.forEach(survey => {
                    // Normalize manager name for consistency
                    let manager = survey.accountManager;
                    if (manager === 'Ahmed Salem') manager = 'Ahmed Saleem';
                    if (!manager) return;

                    if (!accountManagerMetrics[manager]) {
                        accountManagerMetrics[manager] = {
                            completed: 0,
                            pending: 0,
                            completionRate: 0,
                            satisfactionRate: 0,
                            totalAssigned: 0,
                            satisfiedCustomers: 0
                        };
                    }

                    accountManagerMetrics[manager].totalAssigned++;

                    if (survey.submittedAt) {
                        accountManagerMetrics[manager].completed++;

                        // Check if customer is satisfied (rating 4-5)
                        if (survey.overallSatisfaction >= 4) {
                            accountManagerMetrics[manager].satisfiedCustomers++;
                        }
                    } else {
                        accountManagerMetrics[manager].pending++;
                    }
                });

                // Calculate rates
                Object.keys(accountManagerMetrics).forEach(manager => {
                    const metrics = accountManagerMetrics[manager];
                    if (metrics.totalAssigned > 0) {
                        metrics.completionRate = Math.round((metrics.completed / metrics.totalAssigned) * 100 * 10) / 10;
                        if (metrics.completed > 0) {
                            metrics.satisfactionRate = Math.round((metrics.satisfiedCustomers / metrics.completed) * 100 * 10) / 10;
                        }
                    }
                });

                return { accountManagerMetrics };
            }

            updateState() {
                // Update URL hash or localStorage if needed
                if (this.currentQuarter !== 'all') {
                    sessionStorage.setItem('selectedQuarter', this.currentQuarter);
                } else {
                    sessionStorage.removeItem('selectedQuarter');
                }
            }

            // Restore saved quarter on page load
            restoreState() {
                const savedQuarter = sessionStorage.getItem('selectedQuarter');
                const quarterSelect = document.getElementById('quarter-select');

                if (savedQuarter && quarterSelect) {
                    console.log('Restoring saved quarter:', savedQuarter);
                    quarterSelect.value = savedQuarter;
                    this.currentQuarter = savedQuarter;
                } else if (quarterSelect) {
                    // Sync with the current dropdown value
                    const currentValue = quarterSelect.value;
                    console.log('No saved quarter, using dropdown value:', currentValue);
                    this.currentQuarter = currentValue;
                }
            }

            // Get current filter state
            getCurrentFilter() {
                return {
                    quarter: this.currentQuarter,
                    year: new Date().getFullYear()
                };
            }
        }

        // Initialize Quarter Filter
        let quarterFilter;
        document.addEventListener('DOMContentLoaded', function () {
            quarterFilter = new QuarterFilter();

            // Check manager availability after initialization
            setTimeout(() => {
                console.log('Checking managers after 2 seconds:', {
                    csatSummaryManager: !!window.csatSummaryManager,
                    customerStatusManager: !!window.customerStatusManager,
                    accountManagerPerformanceManager: !!window.accountManagerPerformanceManager
                });

                // Restore saved state
                quarterFilter.restoreState();

                // Apply the current quarter filter to ensure all tabs show filtered data
                setTimeout(() => {
                    console.log('Applying initial quarter filter...');
                    quarterFilter.filterAndRefreshData();
                }, 500);
            }, 2000);
        });

        // Make quarter filter globally available
        window.QuarterFilter = QuarterFilter;
        window.quarterFilter = quarterFilter;

        /**
         * Authentication Manager Class
         * Handles password protection for the dashboard
         * Requirements: 1.3, 1.4, 3.1
         */
        class AuthManager {
            constructor() {
                this.isAuthenticated = false;
                this.authToken = localStorage.getItem('auth_token');
                this.sessionKey = "dashboard_auth";
                this.sessionTimeout = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
                this.passwordOverlay = null;
                this.dashboardContainer = null;
                this.passwordForm = null;
                this.passwordInput = null;
                this.errorMessage = null;
                this.init();
            }

            /**
             * Initialize authentication manager
             * Requirements: 1.3, 3.1
             */
            init() {
                this.setupDOMReferences();
                this.checkAuthState();
                this.bindEvents();
                this.setupSessionCleanup();
            }

            /**
             * Set up DOM element references
             */
            setupDOMReferences() {
                this.passwordOverlay = document.getElementById('password-protection');
                this.dashboardContainer = document.querySelector('.dashboard-container');
                this.passwordForm = document.getElementById('password-form');
                this.passwordInput = document.getElementById('password-input');
                this.errorMessage = document.getElementById('error-message');
            }

            /**
             * Check authentication state from sessionStorage
             * Requirements: 3.1, 3.2, 3.3, 3.4, 3.5
             */
            checkAuthState() {
                try {
                    const authData = this.readSessionStorage();
                    if (authData && this.isSessionValid(authData)) {
                        this.isAuthenticated = true;
                        this.showDashboard();
                        return;
                    }
                } catch (error) {
                    console.warn('Error reading authentication state:', error);
                    this.clearSessionStorage();
                }

                // Show password screen if not authenticated or session expired
                this.showPasswordScreen();
            }

            /**
             * Bind event listeners
             * Requirements: 1.3, 1.4
             */
            bindEvents() {
                if (this.passwordForm) {
                    this.passwordForm.addEventListener('submit', (e) => this.handlePasswordSubmit(e));
                }

                if (this.passwordInput) {
                    this.passwordInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.handlePasswordSubmit(e);
                        }
                    });

                    // Clear error message when user starts typing
                    this.passwordInput.addEventListener('input', () => {
                        this.hideError();
                    });
                }
            }

            /**
             * Handle password form submission
             * Requirements: 1.3, 1.4
             */
            async handlePasswordSubmit(event) {
                event.preventDefault();
                
                const password = this.passwordInput ? this.passwordInput.value.trim() : '';
                
                if (!password) {
                    this.showError('Please enter a password');
                    return;
                }

                try {
                    const success = await this.authenticate(password);
                    if (success) {
                        this.onAuthenticationSuccess();
                    } else {
                        this.onAuthenticationFailure();
                    }
                } catch (error) {
                    this.showError('Authentication failed. Please try again.');
                }
            }

            /**
             * Authenticate password with secure backend
             * Requirements: 1.3
             */
            async authenticate(password) {
                try {
                    const response = await fetch(API_CONFIG.endpoints.auth, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ password })
                    });

                    const data = await response.json();
                    
                    if (data.success && data.token) {
                        this.authToken = data.token;
                        localStorage.setItem('auth_token', data.token);
                        return true;
                    }
                    
                    return false;
                } catch (error) {
                    console.error('Authentication error:', error);
                    return false;
                }
            }

            /**
             * Handle successful authentication
             * Requirements: 1.3, 3.1, 3.2
             */
            onAuthenticationSuccess() {
                this.isAuthenticated = true;
                
                // Store authentication state in sessionStorage
                const authData = {
                    authenticated: true,
                    timestamp: Date.now(),
                    sessionId: this.generateSessionId()
                };

                const stored = this.writeSessionStorage(authData);
                if (!stored) {
                    console.warn('Authentication state could not be persisted - session will not survive page refresh');
                }

                // Clear password input
                if (this.passwordInput) {
                    this.passwordInput.value = '';
                }

                // Hide error message
                this.hideError();

                // Show dashboard
                this.showDashboard();
            }

            /**
             * Handle authentication failure
             * Requirements: 1.4
             */
            onAuthenticationFailure() {
                this.showError('Incorrect password. Please try again.');
                
                // Clear password input
                if (this.passwordInput) {
                    this.passwordInput.value = '';
                    this.passwordInput.focus();
                }
            }

            /**
             * Show password protection screen
             * Requirements: 1.1, 1.2
             */
            showPasswordScreen() {
                if (this.passwordOverlay) {
                    this.passwordOverlay.classList.remove('hidden');
                }
                
                if (this.dashboardContainer) {
                    this.dashboardContainer.classList.add('hidden');
                }

                // Focus on password input
                setTimeout(() => {
                    if (this.passwordInput) {
                        this.passwordInput.focus();
                    }
                }, 100);
            }

            /**
             * Show dashboard and hide password screen
             * Requirements: 1.3
             */
            showDashboard() {
                if (this.passwordOverlay) {
                    this.passwordOverlay.classList.add('hidden');
                }
                
                if (this.dashboardContainer) {
                    this.dashboardContainer.classList.remove('hidden');
                }
            }

            /**
             * Show error message with animation
             * Requirements: 1.4
             */
            showError(message) {
                if (this.errorMessage) {
                    this.errorMessage.textContent = message;
                    this.errorMessage.classList.remove('hidden');
                    
                    // Add shake animation
                    this.errorMessage.style.animation = 'none';
                    setTimeout(() => {
                        this.errorMessage.style.animation = 'shake 0.5s ease-in-out';
                    }, 10);
                }
            }

            /**
             * Hide error message
             * Requirements: 1.4
             */
            hideError() {
                if (this.errorMessage) {
                    this.errorMessage.classList.add('hidden');
                }
            }

            /**
             * Read authentication data from sessionStorage
             * Requirements: 3.1, 3.2
             */
            readSessionStorage() {
                try {
                    if (!this.isSessionStorageAvailable()) {
                        console.warn('SessionStorage is not available');
                        return null;
                    }

                    const authData = sessionStorage.getItem(this.sessionKey);
                    if (!authData) {
                        return null;
                    }

                    const parsedAuth = JSON.parse(authData);
                    
                    // Validate required properties
                    if (!parsedAuth.authenticated || !parsedAuth.timestamp || !parsedAuth.sessionId) {
                        console.warn('Invalid session data structure');
                        this.clearSessionStorage();
                        return null;
                    }

                    return parsedAuth;
                } catch (error) {
                    console.error('Error reading session storage:', error);
                    this.clearSessionStorage();
                    return null;
                }
            }

            /**
             * Write authentication data to sessionStorage
             * Requirements: 3.1, 3.2
             */
            writeSessionStorage(authData) {
                try {
                    if (!this.isSessionStorageAvailable()) {
                        console.warn('SessionStorage is not available, authentication will not persist');
                        return false;
                    }

                    sessionStorage.setItem(this.sessionKey, JSON.stringify(authData));
                    return true;
                } catch (error) {
                    console.error('Error writing to session storage:', error);
                    return false;
                }
            }

            /**
             * Clear authentication data from sessionStorage
             * Requirements: 3.3, 3.4
             */
            clearSessionStorage() {
                try {
                    if (this.isSessionStorageAvailable()) {
                        sessionStorage.removeItem(this.sessionKey);
                    }
                } catch (error) {
                    console.error('Error clearing session storage:', error);
                }
            }

            /**
             * Check if sessionStorage is available
             * Requirements: 3.1
             */
            isSessionStorageAvailable() {
                try {
                    const test = '__sessionStorageTest__';
                    sessionStorage.setItem(test, test);
                    sessionStorage.removeItem(test);
                    return true;
                } catch (error) {
                    return false;
                }
            }

            /**
             * Validate if session is still valid
             * Requirements: 3.4, 3.5
             */
            isSessionValid(authData) {
                if (!authData || !authData.authenticated || !authData.timestamp) {
                    return false;
                }

                // Check if session has expired (optional timeout check)
                const currentTime = Date.now();
                const sessionAge = currentTime - authData.timestamp;
                
                // For now, we don't enforce a timeout since requirements specify session-based auth
                // But we validate the session structure and timestamp exists
                if (sessionAge < 0) {
                    console.warn('Invalid session timestamp');
                    return false;
                }

                return true;
            }

            /**
             * Setup session cleanup on browser events
             * Requirements: 3.3, 3.4
             */
            setupSessionCleanup() {
                // Clean up session when page is about to unload (browser close/refresh)
                window.addEventListener('beforeunload', () => {
                    // Note: We don't clear on beforeunload for refresh persistence
                    // Session will naturally expire when browser session ends
                });

                // Handle visibility change (tab switching, minimizing)
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible' && this.isAuthenticated) {
                        // Revalidate session when tab becomes visible
                        const authData = this.readSessionStorage();
                        if (!authData || !this.isSessionValid(authData)) {
                            this.logout();
                        }
                    }
                });

                // Handle storage events (for cross-tab session management)
                window.addEventListener('storage', (event) => {
                    if (event.key === this.sessionKey) {
                        if (event.newValue === null) {
                            // Session was cleared in another tab
                            this.logout();
                        } else {
                            // Session was updated in another tab
                            try {
                                const authData = JSON.parse(event.newValue);
                                if (authData.authenticated && this.isSessionValid(authData)) {
                                    if (!this.isAuthenticated) {
                                        this.isAuthenticated = true;
                                        this.showDashboard();
                                    }
                                } else {
                                    this.logout();
                                }
                            } catch (error) {
                                console.error('Error parsing storage event data:', error);
                            }
                        }
                    }
                });
            }

            /**
             * Generate unique session ID
             */
            generateSessionId() {
                return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            /**
             * Clear authentication state (for logout functionality)
             * Requirements: 3.3, 3.4
             */
            logout() {
                this.isAuthenticated = false;
                this.clearSessionStorage();
                this.showPasswordScreen();
            }
        }

        // Initialize AuthManager when DOM is ready
        let authManager;
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                authManager = new AuthManager();
                window.authManager = authManager;
            });
        } else {
            authManager = new AuthManager();
            window.authManager = authManager;
        }
    </script>
</body>

</html>